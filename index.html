<html lang="zh-TW"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>霓虹注音射擊 - Cyberpunk Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&family=Orbitron:wght@400;700&display=swap');
        
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #bc13fe;
            --neon-green: #0aff0a;
            --neon-yellow: #ffe600;
            --bg-dark: #050510;
        }

        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: var(--bg-dark);
            /* 復古網格背景 */
            background-image: 
                linear-gradient(rgba(0, 243, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(188, 19, 254, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            overflow: hidden;
            height: 100vh;
            margin: 0;
            padding: 0;
            color: white;
        }

        /* 背景星光動畫 - 慢速巡航感 */
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            top: -10px;
            width: var(--size);
            height: var(--size);
            opacity: var(--opacity);
            animation: warpSpeed var(--duration) linear infinite;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
        }

        @keyframes warpSpeed {
            from { transform: translateY(-20px); }
            to { transform: translateY(110vh); }
        }
        
        /* 霓虹文字通用樣式 */
        .neon-text-blue { text-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue); color: var(--neon-blue); }
        .neon-text-pink { text-shadow: 0 0 5px var(--neon-pink), 0 0 10px var(--neon-pink); color: var(--neon-pink); }
        .neon-text-green { text-shadow: 0 0 5px var(--neon-green), 0 0 10px var(--neon-green); color: var(--neon-green); }
        .neon-text-yellow { text-shadow: 0 0 5px var(--neon-yellow), 0 0 10px var(--neon-yellow); color: var(--neon-yellow); }

        .falling-character {
            position: absolute;
            animation-timing-function: linear;
            animation-fill-mode: forwards;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
            /* 霓虹邊框風格 */
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(2px);
            border: 2px solid var(--char-color);
            box-shadow: 0 0 8px var(--char-color), inset 0 0 10px rgba(0,0,0,0.5);
            font-weight: 700;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
            padding: 5px;
            text-align: center;
            z-index: 10;
            color: white;
            text-shadow: 0 0 5px var(--char-color);
        }
        
        .falling-character span.sub-text {
            color: var(--char-color);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            letter-spacing: 1px;
            white-space: nowrap;
        }

        .matched-highlight {
            color: #fff;
            text-shadow: 0 0 5px #fff, 0 0 10px #fff;
            font-weight: 900;
        }

        /* --- 鎖定特效核心 --- */

        /* 鎖定狀態通用: 產生虛線旋轉外框 */
        .falling-character.locking::before {
            content: '';
            position: absolute;
            inset: -8px; /* 擴大範圍 */
            border: 2px dashed var(--lock-color);
            border-radius: 16px;
            animation: rotate-lock var(--lock-speed) linear infinite;
            z-index: -1;
            pointer-events: none;
        }

        @keyframes rotate-lock {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 階段 1: 黃色鎖定 (初期匹配) */
        .falling-character.locking-stage-1 {
            --lock-color: #ffe600; /* 黃色 */
            --lock-speed: 4s;      /* 轉速較慢 */
            border-color: #ffe600;
            box-shadow: 0 0 15px rgba(255, 230, 0, 0.4);
            transform: scale(1.05);
        }

        /* 階段 2: 紅色鎖定 (高度匹配 > 50%) */
        .falling-character.locking-stage-2 {
            --lock-color: #ff0000; /* 紅色 */
            --lock-speed: 1.5s;    /* 轉速變快 */
            border-color: #ff0000;
            box-shadow: 0 0 25px rgba(255, 0, 0, 0.6), inset 0 0 10px rgba(255, 0, 0, 0.3);
            transform: scale(1.15);
            z-index: 20;
        }

        /* 擊中時的爆炸 */
        .explosion-effect {
            position: fixed;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
            border-radius: 12px;
            font-weight: 700;
            padding: 5px;
            text-align: center;
            user-select: none;
            background: var(--char-color);
            box-shadow: 0 0 20px var(--char-color);
            animation: cyber-explode 0.5s ease-out forwards;
        }

        @keyframes cyber-explode {
            0% { transform: scale(1); opacity: 1; filter: brightness(2); }
            40% { transform: scale(1.4); opacity: 0.8; filter: brightness(1.5); }
            100% { transform: scale(0); opacity: 0; filter: brightness(0); }
        }
        
        @keyframes fall {
            from { transform: translateY(-100px); }
            to { transform: translateY(110vh); }
        }
        
        .laser-beam {
            position: absolute;
            height: 6px;
            background: white;
            transform-origin: 0 50%;
            box-shadow: 
                0 0 5px #fff,
                0 0 10px var(--neon-blue),
                0 0 20px var(--neon-blue),
                0 0 30px var(--neon-blue);
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            border-radius: 3px;
            mix-blend-mode: screen;
        }

        .turret-container {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            pointer-events: none;
        }
        
        .turret-base {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #333 30%, transparent 70%);
            border: 2px solid var(--neon-blue);
            border-radius: 50%;
            box-shadow: 0 0 15px var(--neon-blue), inset 0 0 10px var(--neon-blue);
            z-index: 19;
        }

        .turret-icon {
            font-size: 3.5rem;
            color: white;
            filter: drop-shadow(0 0 5px var(--neon-blue)) drop-shadow(0 0 15px var(--neon-blue));
            transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: block;
        }

        .turret-fire {
            animation: recoil 0.1s ease-in-out;
            filter: drop-shadow(0 0 10px #fff) drop-shadow(0 0 20px var(--neon-blue));
        }

        @keyframes recoil {
            0% { transform: translateY(0); }
            50% { transform: translateY(10px); }
            100% { transform: translateY(0); }
        }
        
        /* HUD 樣式 */
        .hud-panel {
            background: rgba(10, 10, 30, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }

        .hud-border-blue { border-left: 3px solid var(--neon-blue); }
        .hud-border-pink { border-left: 3px solid var(--neon-pink); }
        .hud-border-red { border-left: 3px solid #ff3333; }

        .input-area {
            background: transparent;
            z-index: 30;
        }
        
        #input-field {
            background: rgba(5, 5, 16, 0.9);
            border: 2px solid var(--neon-blue);
            color: white;
            font-family: 'Orbitron', 'Noto Sans TC', sans-serif;
            text-shadow: 0 0 5px var(--neon-blue);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3), inset 0 0 10px rgba(0, 243, 255, 0.1);
            letter-spacing: 1px;
            transition: all 0.3s;
        }
        
        #input-field:focus {
            outline: none;
            box-shadow: 0 0 25px rgba(0, 243, 255, 0.5), inset 0 0 15px rgba(0, 243, 255, 0.2);
            border-color: #fff;
        }
        
        #input-field::placeholder {
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.9em;
        }

        /* 按鈕樣式 */
        .cyber-btn {
            background: transparent;
            color: var(--neon-blue);
            border: 2px solid var(--neon-blue);
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
            transition: 0.3s;
            box-shadow: 0 0 10px var(--neon-blue);
            clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%);
        }

        .cyber-btn:hover {
            background: var(--neon-blue);
            color: black;
            box-shadow: 0 0 30px var(--neon-blue);
            transform: scale(1.05);
        }

        /* 分數飄浮動畫 */
        @keyframes floatPoints {
            0% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0); }
            50% { opacity: 0.8; transform: translateY(-30px) scale(1.2); filter: blur(1px); }
            100% { opacity: 0; transform: translateY(-60px) scale(1.5); filter: blur(4px); }
        }

        @media (max-width: 768px) { 
            .falling-character { width: 70px; height: 70px; }
            .explosion-effect { width: 70px; height: 70px; }
            .turret-container { bottom: 90px; }
            .turret-icon { font-size: 2.8rem; }
            .turret-base { width: 50px; height: 50px; bottom: -15px; }
        }
    </style>
</head>
<body>
    <!-- 背景星星 -->
    <div id="stars-container"></div>

    <!-- 開始畫面 -->
    <div id="start-screen" class="fixed inset-0 flex flex-col items-center justify-center z-50 bg-black bg-opacity-90 p-4">
        <div class="border border-cyan-500 p-8 rounded-lg shadow-[0_0_50px_rgba(0,243,255,0.3)] bg-gray-900 bg-opacity-80 max-w-2xl w-full text-center relative overflow-hidden">
            <!-- 裝飾線條 -->
            <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-cyan-500 to-transparent"></div>
            <div class="absolute bottom-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-purple-500 to-transparent"></div>
            
            <h1 class="text-5xl md:text-7xl font-black mb-4 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-white to-purple-500 neon-text-blue tracking-wider" style="font-family: 'Orbitron', sans-serif;">TYPE<br><span class="text-4xl md:text-6xl font-serif">注音特攻</span></h1>
            
            <div class="flex justify-center gap-4 mb-8 text-cyan-200">
                <div class="border border-cyan-500/30 px-4 py-2 rounded bg-black/50">
                    <i class="fas fa-keyboard mr-2"></i>注音輸入
                </div>
                <div class="border border-purple-500/30 px-4 py-2 rounded bg-black/50">
                    <i class="fas fa-bullseye mr-2"></i>自動鎖定
                </div>
            </div>

            <p class="text-lg md:text-xl mb-8 text-gray-300 font-light">
                系統偵測到大量未知訊號入侵。<br>
                啟動防禦矩陣，準備攔截。
            </p>
            
            <button id="start-button" class="cyber-btn px-10 py-4 text-xl font-bold">INITIATE_SYSTEM</button>
        </div>
    </div>

    <!-- 遊戲畫面 -->
    <div id="game-container" class="hidden h-screen w-full relative">
        <!-- HUD 狀態欄 -->
        <div class="fixed top-0 left-0 right-0 p-2 sm:p-4 flex flex-wrap justify-between items-start gap-2 z-40 pointer-events-none px-4 md:px-10">
            <!-- 左上：分數 -->
            <div class="hud-panel hud-border-blue px-6 py-2 rounded-br-2xl">
                <div class="text-xs text-cyan-300 tracking-widest uppercase mb-1">Score</div>
                <span id="score" class="text-2xl font-bold text-white font-mono neon-text-blue">000000</span>
            </div>

            <!-- 中間：擊落數 -->
            <div class="hud-panel hud-border-pink px-6 py-2 rounded-b-xl">
                <div class="text-xs text-purple-300 tracking-widest uppercase mb-1 text-center">Targets Neutralized</div>
                <div class="text-center">
                    <span id="completed-count" class="text-2xl font-bold text-white font-mono neon-text-pink">0</span>
                </div>
            </div>

            <!-- 右上：生命值/入侵 -->
            <div class="hud-panel hud-border-red px-6 py-2 rounded-bl-2xl">
                <div class="text-xs text-red-300 tracking-widest uppercase mb-1 text-right">System Integrity</div>
                <div class="flex items-center justify-end gap-2">
                    <div class="w-24 h-2 bg-gray-700 rounded overflow-hidden">
                        <div id="health-bar" class="h-full bg-red-500 shadow-[0_0_10px_red]" style="width: 100%;"></div>
                    </div>
                    <span id="missed-count" class="text-xl font-bold text-red-500 font-mono">0/5</span>
                </div>
            </div>
        </div>
        
        <div id="characters-container" class="w-full h-full"></div>
        
        <!-- 砲塔 -->
        <div class="turret-base"></div>
        <div id="turret" class="turret-container">
            <i class="fas fa-rocket turret-icon transform -rotate-45"></i>
        </div>

        <div class="fixed bottom-0 left-0 right-0 p-4 pb-6 input-area flex justify-center">
            <div class="relative w-full max-w-2xl">
                <input type="text" id="input-field" class="w-full px-6 py-4 text-xl rounded-lg text-center" placeholder="AWAITING COMMAND [ 輸入注音 ]" autocomplete="off">
                <div class="absolute right-4 top-1/2 transform -translate-y-1/2 text-cyan-500 opacity-50 text-xs hidden sm:block">
                    CMD: TYPE TO FIRE
                </div>
            </div>
            
            <div class="absolute bottom-4 right-4 text-xs text-gray-500 font-mono hidden md:block">
                INPUT: <span class="text-cyan-400">READY</span> | TURRET: <span class="text-cyan-400">ONLINE</span>
            </div>
        </div>
    </div>
    
    <!-- 遊戲結束 -->
    <div id="game-over" class="hidden fixed inset-0 flex flex-col items-center justify-center z-50 bg-black bg-opacity-90 p-4 backdrop-blur-sm">
        <div class="bg-gray-900 border-2 border-red-500 p-1 rounded-2xl shadow-[0_0_100px_rgba(255,0,0,0.4)] max-w-md w-full relative">
            <div class="absolute -top-3 -left-3 w-6 h-6 border-t-4 border-l-4 border-red-500"></div>
            <div class="absolute -bottom-3 -right-3 w-6 h-6 border-b-4 border-r-4 border-red-500"></div>
            
            <div class="p-6 md:p-8 rounded-xl bg-gradient-to-b from-gray-900 to-black">
                <h2 id="game-over-title" class="text-3xl md:text-4xl font-bold mb-6 text-center text-red-500 neon-text-red tracking-widest uppercase" style="font-family: 'Orbitron', sans-serif;">Mission Failed</h2>
                
                <div class="grid grid-cols-2 gap-4 mb-6">
                    <div class="bg-gray-800/50 p-3 rounded border border-gray-700">
                        <div class="text-xs text-gray-400 uppercase">Final Score</div>
                        <div id="final-score" class="text-xl font-bold text-yellow-400 font-mono">0</div>
                    </div>
                    <div class="bg-gray-800/50 p-3 rounded border border-gray-700">
                        <div class="text-xs text-gray-400 uppercase">Targets</div>
                        <div id="final-completed" class="text-xl font-bold text-cyan-400 font-mono">0</div>
                    </div>
                </div>

                <div class="bg-blue-900/20 border border-blue-500/30 p-4 rounded-lg mb-6 text-center">
                    <div class="text-sm text-blue-300 mb-1">RANKING</div>
                    <div id="rank-display" class="text-2xl font-bold text-white neon-text-blue">-</div>
                    <div id="high-score-display" class="text-xs text-gray-400 mt-2"></div>
                </div>
                
                <div class="mb-8">
                    <h3 class="text-sm font-bold text-gray-500 mb-2 uppercase tracking-wide border-b border-gray-800 pb-1">Leaderboard</h3>
                    <div id="top10-list" class="space-y-1 text-xs max-h-32 overflow-y-auto custom-scrollbar"></div>
                </div>
                
                <div class="flex justify-center">
                    <button id="restart-button" class="cyber-btn px-8 py-3 text-lg font-bold w-full">REBOOT_SYSTEM</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ----------------------------------------------------
        // 視覺特效初始化
        // ----------------------------------------------------
        function initStars() {
            const container = document.getElementById('stars-container');
            // 增加星星數量以強化速度感
            for(let i=0; i<150; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                const speedFactor = Math.random();
                const size = 1 + speedFactor * 2;
                star.style.setProperty('--size', `${size}px`);
                const opacity = 0.3 + speedFactor * 0.7;
                star.style.setProperty('--opacity', opacity);
                const duration = 20 - (speedFactor * 12);
                star.style.setProperty('--duration', `${duration}s`);
                star.style.animationDelay = `-${Math.random() * 20}s`;
                container.appendChild(star);
            }
        }
        initStars();

        const neonColors = [
            { color: '#00f3ff', name: 'blue' },
            { color: '#bc13fe', name: 'pink' },
            { color: '#0aff0a', name: 'green' },
            { color: '#ffe600', name: 'yellow' }
        ];

        // ----------------------------------------------------
        // 遊戲邏輯
        // ----------------------------------------------------
        const bopomofoKeyMap = {
            'ㄅ': '1', 'ㄆ': 'q', 'ㄇ': 'a', 'ㄈ': 'z', 'ㄉ': '2', 'ㄊ': 'w', 'ㄋ': 's', 'ㄌ': 'x',
            'ㄍ': 'e', 'ㄎ': 'd', 'ㄏ': 'c', 'ㄐ': 'r', 'ㄑ': 'f', 'ㄒ': 'v', 'ㄓ': '5', 'ㄔ': 't',
            'ㄕ': 'g', 'ㄖ': 'b', 'ㄗ': 'y', 'ㄘ': 'h', 'ㄙ': 'n', 'ㄧ': 'u', 'ㄨ': 'j', 'ㄩ': 'm',
            'ㄚ': '8', 'ㄛ': 'i', 'ㄜ': 'k', 'ㄝ': ',', 'ㄞ': '9', 'ㄟ': 'o', 'ㄠ': 'l', 'ㄡ': '.',
            'ㄢ': '0', 'ㄣ': 'p', 'ㄤ': ';', 'ㄥ': '/', 'ㄦ': '-',
            'ˊ': '6', 'ˇ': '3', 'ˋ': '4', '˙': '7'
        };

        const characterData = [
            { char: '的', bopomofo: 'ㄉㄜ˙' }, { char: '一', bopomofo: 'ㄧ' }, { char: '是', bopomofo: 'ㄕˋ' }, { char: '不', bopomofo: 'ㄅㄨˋ' },
            { char: '了', bopomofo: 'ㄌㄜ˙' }, { char: '有', bopomofo: 'ㄧㄡˇ' }, { char: '和', bopomofo: 'ㄏㄜˊ' }, { char: '人', bopomofo: 'ㄖㄣˊ' },
            { char: '這', bopomofo: 'ㄓㄜˋ' }, { char: '中', bopomofo: 'ㄓㄨㄥ' }, { char: '大', bopomofo: 'ㄉㄚˋ' }, { char: '為', bopomofo: 'ㄨㄟˊ' },
            { char: '上', bopomofo: 'ㄕㄤˋ' }, { char: '個', bopomofo: 'ㄍㄜˋ' }, { char: '國', bopomofo: 'ㄍㄨㄛˊ' }, { char: '我', bopomofo: 'ㄨㄛˇ' },
            { char: '以', bopomofo: 'ㄧˇ' }, { char: '要', bopomofo: 'ㄧㄠˋ' }, { char: '他', bopomofo: 'ㄊㄚ' }, { char: '時', bopomofo: 'ㄕˊ' },
            { char: '來', bopomofo: 'ㄌㄞˊ' }, { char: '用', bopomofo: 'ㄩㄥˋ' }, { char: '們', bopomofo: 'ㄇㄣ˙' }, { char: '生', bopomofo: 'ㄕㄥ' },
            { char: '到', bopomofo: 'ㄉㄠˋ' }, { char: '作', bopomofo: 'ㄗㄨㄛˋ' }, { char: '地', bopomofo: 'ㄉㄧˋ' }, { char: '於', bopomofo: 'ㄩˊ' },
            { char: '出', bopomofo: 'ㄔㄨ' }, { char: '就', bopomofo: 'ㄐㄧㄡˋ' }, { char: '分', bopomofo: 'ㄈㄣ' }, { char: '對', bopomofo: 'ㄉㄨㄟˋ' },
            { char: '成', bopomofo: 'ㄔㄥˊ' }, { char: '會', bopomofo: 'ㄏㄨㄟˋ' }, { char: '可', bopomofo: 'ㄎㄜˇ' }, { char: '主', bopomofo: 'ㄓㄨˇ' },
            { char: '發', bopomofo: 'ㄈㄚ' }, { char: '年', bopomofo: 'ㄋㄧㄢˊ' }, { char: '動', bopomofo: 'ㄉㄨㄥˋ' }, { char: '同', bopomofo: 'ㄊㄨㄥˊ' },
            { char: '工', bopomofo: 'ㄍㄨㄥ' }, { char: '也', bopomofo: 'ㄧㄝˇ' }, { char: '能', bopomofo: 'ㄋㄥˊ' }, { char: '下', bopomofo: 'ㄒㄧㄚˋ' },
            { char: '過', bopomofo: 'ㄍㄨㄛˋ' }, { char: '子', bopomofo: 'ㄗˇ' }, { char: '說', bopomofo: 'ㄕㄨㄛ' }, { char: '產', bopomofo: 'ㄔㄢˇ' },
            { char: '種', bopomofo: 'ㄓㄨㄥˇ' }, { char: '面', bopomofo: 'ㄇㄧㄢˋ' }, { char: '而', bopomofo: 'ㄦˊ' }, { char: '方', bopomofo: 'ㄈㄤ' },
            { char: '後', bopomofo: 'ㄏㄡˋ' }, { char: '多', bopomofo: 'ㄉㄨㄛ' }, { char: '定', bopomofo: 'ㄉㄧㄥˋ' }, { char: '行', bopomofo: 'ㄒㄧㄥˊ' },
            { char: '學', bopomofo: 'ㄒㄩㄝˊ' }, { char: '法', bopomofo: 'ㄈㄚˇ' }, { char: '所', bopomofo: 'ㄙㄨㄛˇ' }, { char: '民', bopomofo: 'ㄇㄧㄣˊ' },
            { char: '得', bopomofo: 'ㄉㄜˊ' }, { char: '經', bopomofo: 'ㄐㄧㄥ' }, { char: '十', bopomofo: 'ㄕˊ' }, { char: '三', bopomofo: 'ㄙㄢ' },
            { char: '之', bopomofo: 'ㄓ' }, { char: '進', bopomofo: 'ㄐㄧㄣˋ' }, { char: '著', bopomofo: 'ㄓㄜ˙' }, { char: '等', bopomofo: 'ㄉㄥˇ' },
            { char: '部', bopomofo: 'ㄅㄨˋ' }, { char: '度', bopomofo: 'ㄉㄨˋ' }, { char: '家', bopomofo: 'ㄐㄧㄚ' }, { char: '電', bopomofo: 'ㄉㄧㄢˋ' },
            { char: '力', bopomofo: 'ㄌㄧˋ' }, { char: '裡', bopomofo: 'ㄌㄧˇ' }, { char: '如', bopomofo: 'ㄖㄨˊ' }, { char: '水', bopomofo: 'ㄕㄨㄟˇ' },
            { char: '化', bopomofo: 'ㄏㄨㄚˋ' }, { char: '高', bopomofo: 'ㄍㄠ' }, { char: '自', bopomofo: 'ㄗˋ' }, { char: '二', bopomofo: 'ㄦˋ' },
            { char: '理', bopomofo: 'ㄌㄧˇ' }, { char: '起', bopomofo: 'ㄑㄧˇ' }, { char: '小', bopomofo: 'ㄒㄧㄠˇ' }, { char: '物', bopomofo: 'ㄨˋ' },
            { char: '現', bopomofo: 'ㄒㄧㄢˋ' }, { char: '實', bopomofo: 'ㄕˊ' }, { char: '加', bopomofo: 'ㄐㄧㄚ' }, { char: '量', bopomofo: 'ㄌㄧㄤˋ' },
            { char: '都', bopomofo: 'ㄉㄡ' }, { char: '兩', bopomofo: 'ㄌㄧㄤˇ' }, { char: '體', bopomofo: 'ㄊㄧˇ' }, { char: '制', bopomofo: 'ㄓˋ' },
            { char: '機', bopomofo: 'ㄐㄧ' }, { char: '當', bopomofo: 'ㄉㄤ' }, { char: '使', bopomofo: 'ㄕˇ' }, { char: '點', bopomofo: 'ㄉㄧㄢˇ' },
            { char: '從', bopomofo: 'ㄘㄨㄥˊ' }, { char: '業', bopomofo: 'ㄧㄝˋ' }, { char: '本', bopomofo: 'ㄅㄣˇ' }, { char: '去', bopomofo: 'ㄑㄩˋ' },
            { char: '把', bopomofo: 'ㄅㄚˇ' }, { char: '長', bopomofo: 'ㄓㄤˇ' }, { char: '見', bopomofo: 'ㄐㄧㄢˋ' }, { char: '己', bopomofo: 'ㄐㄧˇ' },
            { char: '重', bopomofo: 'ㄓㄨㄥˋ' }, { char: '此', bopomofo: 'ㄘˇ' }, { char: '間', bopomofo: 'ㄐㄧㄢ' }, { char: '向', bopomofo: 'ㄒㄧㄤˋ' },
            { char: '道', bopomofo: 'ㄉㄠˋ' }, { char: '命', bopomofo: 'ㄇㄧㄥˋ' }, { char: '想', bopomofo: 'ㄒㄧㄤˇ' }, { char: '情', bopomofo: 'ㄑㄧㄥˊ' },
            { char: '事', bopomofo: 'ㄕˋ' }, { char: '知', bopomofo: 'ㄓ' }, { char: '者', bopomofo: 'ㄓㄜˇ' }, { char: '給', bopomofo: 'ㄍㄟˇ' },
            { char: '次', bopomofo: 'ㄘˋ' }, { char: '你', bopomofo: 'ㄋㄧˇ' }, { char: '好', bopomofo: 'ㄏㄠˇ' }, { char: '朋', bopomofo: 'ㄆㄥˊ' },
            { char: '友', bopomofo: 'ㄧㄡˇ' }, { char: '她', bopomofo: 'ㄊㄚ' }, { char: '快', bopomofo: 'ㄎㄨㄞˋ' }, { char: '樂', bopomofo: 'ㄌㄜˋ' },
            { char: '愛', bopomofo: 'ㄞˋ' }, { char: '光', bopomofo: 'ㄍㄨㄤ' }, { char: '風', bopomofo: 'ㄈㄥ' }, { char: '花', bopomofo: 'ㄏㄨㄚ' },
            { char: '山', bopomofo: 'ㄕㄢ' }, { char: '天', bopomofo: 'ㄊㄧㄢ' }, { char: '鳥', bopomofo: 'ㄋㄧㄠˇ' },
            { char: '魚', bopomofo: 'ㄩˊ' }, { char: '書', bopomofo: 'ㄕㄨ' }, { char: '看', bopomofo: 'ㄎㄢˋ' }, { char: '聽', bopomofo: 'ㄊㄧㄥ' }
        ];

        function convertBopomofoToEnglish(bopomofo) {
            const tones = ['ˊ', 'ˇ', 'ˋ', '˙'];
            let keyString = '';
            let hasTone = false;
            for (const char of bopomofo) {
                if (bopomofoKeyMap[char]) {
                    keyString += bopomofoKeyMap[char];
                    if (tones.includes(char)) {
                        hasTone = true;
                    }
                }
            }
            if (!hasTone) {
                keyString += ' '; // 一聲以空白鍵結尾
            }
            return keyString;
        }

        const characterDataWithKeys = characterData.map(data => ({
            ...data,
            englishKeys: convertBopomofoToEnglish(data.bopomofo)
        }));

        let gameActive = false;
        let fallingCharacters = [];
        let completedCount = 0;
        let score = 0;
        let missedCount = 0; 
        let maxMisses = 5;
        let isComposing = false;
        let turretResetTimeout;
        
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameContainer = document.getElementById('game-container');
        const charactersContainer = document.getElementById('characters-container');
        const inputField = document.getElementById('input-field');
        const completedCountElement = document.getElementById('completed-count');
        const scoreElement = document.getElementById('score');
        const missedCountElement = document.getElementById('missed-count');
        const healthBar = document.getElementById('health-bar');
        const gameOverScreen = document.getElementById('game-over');
        const gameOverTitle = document.getElementById('game-over-title');
        const finalCompletedElement = document.getElementById('final-completed');
        const finalScoreElement = document.getElementById('final-score');
        const rankDisplayElement = document.getElementById('rank-display');
        const highScoreDisplayElement = document.getElementById('high-score-display');
        const top10ListElement = document.getElementById('top10-list');
        const restartButton = document.getElementById('restart-button');
        const turretElement = document.getElementById('turret');
        const turretIcon = turretElement.querySelector('i');
        
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        
        function getRandomUniqueCharacter() {
            const onScreenChars = fallingCharacters.map(fc => fc.char);
            let availableCharsData = characterDataWithKeys.filter(data => !onScreenChars.includes(data.char));
            if (availableCharsData.length === 0) {
                availableCharsData = [...characterDataWithKeys];
            }
            const randomIndex = Math.floor(Math.random() * availableCharsData.length);
            return availableCharsData[randomIndex];
        }

        function getCurrentMaxCharacters() {
            return Math.floor(completedCount / 20) + 1;
        }

        function saveScore(completed, score, missed) {
            const scoreData = {
                completed: completed,
                score: score,
                missed: missed,
                date: new Date().toISOString(),
                timestamp: Date.now()
            };
            let scores = getScores();
            scores.push(scoreData);
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 10);
            localStorage.setItem('typingGameScores', JSON.stringify(scores));
            return scoreData;
        }
        
        function getScores() {
            const stored = localStorage.getItem('typingGameScores');
            return stored ? JSON.parse(stored) : [];
        }
        
        function calculateRank(currentScore) {
            const scores = getScores();
            if (scores.length === 0) return { rank: 1, isNewRecord: false, inTop10: true, highScore: null };
            const sortedScores = [...scores].sort((a, b) => b.score - a.score);
            const highScore = sortedScores[0].score;
            let rank = 1;
            for (let i = 0; i < sortedScores.length; i++) {
                if (currentScore > sortedScores[i].score) {
                    rank = i + 1;
                    break;
                } else if (i === sortedScores.length - 1) {
                    rank = sortedScores.length + 1;
                }
            }
            return { rank: rank, isNewRecord: currentScore > highScore, inTop10: rank <= 10, highScore: highScore };
        }
        
        function displayRankInfo(rank, isNewRecord, inTop10, highScore, currentScore) {
            if (inTop10) {
                rankDisplayElement.textContent = `RANK #${rank}`;
                rankDisplayElement.className = 'text-2xl font-bold font-mono neon-text-blue';
            } else {
                rankDisplayElement.textContent = 'UNRANKED';
                rankDisplayElement.className = 'text-2xl font-bold font-mono text-gray-500';
            }
            
            if (rank === 1 && !highScore) {
                highScoreDisplayElement.innerHTML = '<span class="text-cyan-400">NEW ACE PILOT ESTABLISHED</span>';
            } else if (isNewRecord) {
                highScoreDisplayElement.innerHTML = '<span class="text-yellow-400 font-bold">NEW HIGH SCORE RECORDED</span>';
            } else if (inTop10) {
                const difference = highScore - currentScore;
                highScoreDisplayElement.innerHTML = `<span class="text-gray-400">HIGH SCORE: ${highScore}</span><br><span class="text-sm text-gray-500">-${difference} TO LEAD</span>`;
            } else {
                const scores = getScores();
                const lowestTop10Score = scores[Math.min(9, scores.length - 1)]?.score || 0;
                const difference = lowestTop10Score - currentScore + 1;
                highScoreDisplayElement.innerHTML = `<span class="text-gray-400">TARGET ACQUIRED</span><br><span class="text-sm text-gray-500">-${difference} TO RANK</span>`;
            }
        }
        
        function getTop10Scores() {
            const scores = getScores();
            return [...scores].sort((a, b) => b.score - a.score).slice(0, 10);
        }
        
        function displayTop10(currentScore) {
            const top10 = getTop10Scores();
            if (top10.length === 0) {
                top10ListElement.innerHTML = '<p class="text-center text-gray-500">NO DATA FOUND</p>';
                return;
            }
            
            let html = '';
            top10.forEach((scoreData, index) => {
                const rank = index + 1;
                const isCurrentScore = Math.abs(scoreData.timestamp - Date.now()) < 1000;
                const bgClass = isCurrentScore ? 'bg-cyan-900/50 border border-cyan-500' : 'bg-gray-800/30 border border-gray-700';
                const textClass = isCurrentScore ? 'text-white' : 'text-gray-400';
                
                html += `
                    <div class="${bgClass} p-2 rounded flex justify-between items-center transition hover:bg-gray-700/50">
                        <div class="flex items-center gap-2 flex-1">
                            <span class="font-bold font-mono w-6 ${rank <= 3 ? 'text-yellow-400' : 'text-gray-500'}">#${rank}</span>
                            <div class="flex-1">
                                <div class="flex justify-between">
                                    <span class="font-bold text-cyan-300 font-mono">${scoreData.score.toString().padStart(6, '0')}</span>
                                    <span class="text-[10px] text-gray-500">${new Date(scoreData.date).toLocaleDateString()}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            top10ListElement.innerHTML = html;
        }

        function updateHealthBar() {
            const percentage = ((maxMisses - missedCount) / maxMisses) * 100;
            healthBar.style.width = `${Math.max(0, percentage)}%`;
            if (percentage < 30) {
                healthBar.className = "h-full bg-red-600 shadow-[0_0_15px_red] animate-pulse";
            } else {
                healthBar.className = "h-full bg-green-500 shadow-[0_0_10px_lime]";
            }
        }

        function spawnNewCharacter() {
            if (!gameActive) return;

            const maxChars = getCurrentMaxCharacters();
            if (fallingCharacters.length >= maxChars) return;

            const charData = getRandomUniqueCharacter();
            if (!charData) return; 

            // 隨機分配一個霓虹色
            const neonStyle = neonColors[Math.floor(Math.random() * neonColors.length)];

            const charElement = document.createElement('div');
            charElement.className = 'falling-character';
            charElement.style.setProperty('--char-color', neonStyle.color);
            
            // 移除 lock-ring
            charElement.innerHTML = `
                <span class="text-3xl filter drop-shadow-[0_0_5px_rgba(255,255,255,0.8)]">${charData.char}</span>
                <span class="sub-text mt-1">${charData.bopomofo} <span class="opacity-70">[${charData.englishKeys}]</span></span>
            `;
            
            charElement.dataset.char = charData.char;
            charElement.dataset.bopomofo = charData.bopomofo;
            charElement.dataset.englishKeys = charData.englishKeys;
            charElement.dataset.neonColor = neonStyle.color;

            const containerWidth = charactersContainer.clientWidth;
            let effectiveCharWidth = 80;
            if (window.innerWidth <= 768) effectiveCharWidth = 70;
            if (window.innerWidth <= 640) effectiveCharWidth = 65;

            const left = Math.random() * (containerWidth - effectiveCharWidth);
            charElement.style.left = `${Math.max(0, left)}px`;

            const duration = 15 + Math.random() * 10;
            charElement.style.animationName = 'fall';
            charElement.style.animationDuration = `${duration}s`;

            charactersContainer.appendChild(charElement);

            const newFcData = {
                element: charElement,
                char: charData.char,
                bopomofo: charData.bopomofo,
                englishKeys: charData.englishKeys,
                duration: duration,
                startTime: Date.now(),
                isHit: false,
                neonColor: neonStyle.color
            };
            fallingCharacters.push(newFcData);

            charElement.addEventListener('animationend', function handleAnimationEnd(e) {
                this.removeEventListener('animationend', handleAnimationEnd);
                const index = fallingCharacters.findIndex(fc => fc.element === this);
                
                if (index > -1 && !fallingCharacters[index].isHit) {
                    fallingCharacters.splice(index, 1);
                    if (this.parentNode) {
                        this.parentNode.removeChild(this);
                    }
                    
                    if (gameActive) {
                        missedCount++;
                        missedCountElement.textContent = `${missedCount}/${maxMisses}`;
                        updateHealthBar();
                        
                        gameContainer.classList.add('animate-pulse');
                        setTimeout(() => gameContainer.classList.remove('animate-pulse'), 200);

                        if (missedCount >= maxMisses) {
                            endGame("SYSTEM FAILURE");
                            return;
                        }
                        
                        const maxChars = getCurrentMaxCharacters();
                        while (fallingCharacters.length < maxChars && gameActive) {
                            spawnNewCharacter();
                        }
                    }
                }
            });
        }

        function startGame() {
            startScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            gameOverScreen.classList.add('hidden');
            
            gameActive = true;
            completedCount = 0;
            score = 0;
            missedCount = 0;
            fallingCharacters = [];
            charactersContainer.innerHTML = ''; 
            
            completedCountElement.textContent = completedCount;
            scoreElement.textContent = score.toString().padStart(6, '0');
            missedCountElement.textContent = `0/${maxMisses}`;
            updateHealthBar();
            
            inputField.focus();
            inputField.value = '';
            updateTargetLocking('');
            setupInputListeners();
            
            turretIcon.style.transform = 'rotate(-45deg)';

            const maxChars = getCurrentMaxCharacters();
            for (let i = 0; i < maxChars; i++) {
                spawnNewCharacter();
            }
        }
        
        function fireLaser(targetFc) {
            const turretRect = turretIcon.getBoundingClientRect();
            const targetRect = targetFc.element.getBoundingClientRect();
            
            const startX = turretRect.left + turretRect.width / 2;
            const startY = turretRect.top + turretRect.height / 2;
            const endX = targetRect.left + targetRect.width / 2;
            const endY = targetRect.top + targetRect.height / 2;
            
            const deltaX = endX - startX;
            const deltaY = endY - startY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
            
            const rotation = angle + 45;

            if (turretResetTimeout) clearTimeout(turretResetTimeout);

            turretIcon.style.transform = `rotate(${rotation}deg)`; 
            turretIcon.parentElement.classList.remove('turret-fire');
            void turretIcon.parentElement.offsetWidth;
            turretIcon.parentElement.classList.add('turret-fire');

            turretResetTimeout = setTimeout(() => {
                if (gameActive) {
                     turretIcon.style.transform = 'rotate(-45deg)';
                }
            }, 600);

            const laser = document.createElement('div');
            laser.className = 'laser-beam';
            laser.style.width = `${distance}px`;
            laser.style.left = `${startX}px`;
            laser.style.top = `${startY}px`;
            laser.style.transform = `rotate(${angle}deg)`;
            
            document.body.appendChild(laser);
            
            const anim = laser.animate([
                { width: '0px', opacity: 0.8 },
                { width: `${distance}px`, opacity: 1 },
                { width: `${distance}px`, opacity: 0 }
            ], {
                duration: 150,
                easing: 'ease-out'
            });
            
            anim.onfinish = () => {
                laser.remove();
                triggerExplosion(targetFc);
            };
        }

        function triggerExplosion(fc) {
            const rect = fc.element.getBoundingClientRect();
            const neonColor = fc.neonColor;

            const explosion = document.createElement('div');
            explosion.className = 'explosion-effect'; 
            explosion.innerHTML = fc.element.innerHTML;
            explosion.style.left = rect.left + 'px';
            explosion.style.top = rect.top + 'px';
            // 讓爆炸繼承原本的霓虹色
            explosion.style.setProperty('--char-color', neonColor);
            
            fc.element.remove();
            
            document.body.appendChild(explosion);
            
            explosion.addEventListener('animationend', () => {
                explosion.remove();
            });
            
            const elapsedTime = (Date.now() - fc.startTime) / 1000;
            const speedBonus = Math.max(1, Math.floor(10 - elapsedTime * 0.5));
            const pointsEarned = 50 + speedBonus * 5;
            
            score += pointsEarned;
            scoreElement.textContent = score.toString().padStart(6, '0');
            
            const pointsIndicator = document.createElement('div');
            pointsIndicator.textContent = `+${pointsEarned}`;
            pointsIndicator.className = 'absolute font-bold text-xl z-30 font-mono';
            pointsIndicator.style.color = neonColor;
            pointsIndicator.style.textShadow = `0 0 10px ${neonColor}`;
            pointsIndicator.style.left = `${rect.left + window.scrollX}px`;
            pointsIndicator.style.top = `${rect.top + window.scrollY}px`;
            pointsIndicator.style.animation = 'floatPoints 0.8s forwards ease-out';
            document.body.appendChild(pointsIndicator);
            setTimeout(() => pointsIndicator.remove(), 800);
            
            const fcIndex = fallingCharacters.findIndex(item => item === fc);
            if (fcIndex !== -1) {
                fallingCharacters.splice(fcIndex, 1);
            }
            
            completedCount++;
            completedCountElement.textContent = completedCount;
            
            if (gameActive) {
                const maxChars = getCurrentMaxCharacters();
                while (fallingCharacters.length < maxChars && gameActive) {
                    spawnNewCharacter();
                }
            }
        }

        let inputListenersSetup = false;
        
        function setupInputListeners() {
            if (inputListenersSetup) return;

            const inputHandler = (e) => {
                if (!isComposing) {
                    const inputValue = e.target.value;
                    
                    if (inputValue.toLowerCase() === 'quit') {
                        const confirmed = confirm('ABORT MISSION?');
                        if (confirmed) {
                            endGame('MISSION ABORTED');
                        }
                        inputField.value = '';
                        updateTargetLocking('');
                        return;
                    }
                    
                    updateTargetLocking(inputValue);
                    processInput(inputValue);
                    
                    const toneKeys = ['3', '4', '6', '7'];
                    const lastChar = inputValue.slice(-1);
                    if (toneKeys.includes(lastChar)) {
                        setTimeout(() => {
                            if (!isComposing) {
                                inputField.value = '';
                                updateTargetLocking('');
                            }
                        }, 10);
                    }
                }
            };

            const compositionStartHandler = () => { isComposing = true; };
            const compositionUpdateHandler = (e) => { if (e.data) updateTargetLocking(e.data); };
            const compositionEndHandler = (e) => {
                isComposing = false;
                processInput(e.data || e.target.value);
                setTimeout(() => {
                    if (inputField.value === (e.data || e.target.value)) {
                       inputField.value = '';
                       updateTargetLocking('');
                    }
                }, 0);
            };
            
            const keyDownHandler = (e) => {
                if (e.key === ' ') {
                    const currentInput = e.target.value;
                    if (!currentInput) return;
                    const potentialMatch = currentInput + ' ';
                    const targetFc = findMatchingChar(potentialMatch);
                    e.preventDefault();
                    if (targetFc) {
                        handleHitLogic(targetFc);
                    }
                    inputField.value = '';
                    updateTargetLocking('');
                }
            };

            inputField.removeEventListener('input', inputHandler);
            inputField.removeEventListener('keydown', keyDownHandler);
            inputField.removeEventListener('compositionstart', compositionStartHandler);
            inputField.removeEventListener('compositionupdate', compositionUpdateHandler);
            inputField.removeEventListener('compositionend', compositionEndHandler);

            inputField.addEventListener('input', inputHandler);
            inputField.addEventListener('keydown', keyDownHandler);
            inputField.addEventListener('compositionstart', compositionStartHandler);
            inputField.addEventListener('compositionupdate', compositionUpdateHandler);
            inputField.addEventListener('compositionend', compositionEndHandler);

            inputListenersSetup = true;
        }

        function findMatchingChar(typedValue) {
            let targetFc = null;
            let maxProgress = -1;

            for (const fc of fallingCharacters) {
                if (fc.isHit) continue;
                
                if ((fc.bopomofo === typedValue || fc.char === typedValue || fc.englishKeys.toLowerCase() === typedValue.toLowerCase()) && fc.element.parentNode) {
                    const elapsedTime = (Date.now() - fc.startTime) / 1000;
                    const progress = elapsedTime / fc.duration;
                    if (progress > maxProgress) {
                        maxProgress = progress;
                        targetFc = fc;
                    }
                }
            }
            return targetFc;
        }

        function handleHitLogic(fc) {
            if (fc.isHit) return;
            fc.isHit = true;
            fc.element.classList.remove('locking'); // 清除鎖定
            fc.element.classList.remove('locking-stage-1');
            fc.element.classList.remove('locking-stage-2');
            fireLaser(fc);
        }
        
        function processInput(inputValue) {
            if (!inputValue || !gameActive) return;
            const targetFc = findMatchingChar(inputValue);

            if (targetFc) {
                handleHitLogic(targetFc);
                if (!isComposing) {
                    inputField.value = '';
                }
            }
        }
        
        // 核心修正：多階段鎖定邏輯
        function updateTargetLocking(inputValue) {
            fallingCharacters.forEach(fc => {
                if (!fc.element.parentNode || fc.isHit) return;
                
                let matchLength = 0;
                let isEnglishMatch = false;
                let isBopomofoMatch = false;
                
                if (inputValue) {
                    const engKeys = fc.englishKeys.toLowerCase();
                    const inputLower = inputValue.toLowerCase();
                    
                    if (engKeys.startsWith(inputLower)) {
                        isEnglishMatch = true;
                        matchLength = inputLower.length;
                    } else if (fc.bopomofo.startsWith(inputValue)) {
                        isBopomofoMatch = true;
                        matchLength = inputValue.length;
                    }
                }

                const subTextEl = fc.element.querySelector('.sub-text');
                
                // 重置所有鎖定狀態
                fc.element.classList.remove('locking');
                fc.element.classList.remove('locking-stage-1');
                fc.element.classList.remove('locking-stage-2');

                if (isEnglishMatch || isBopomofoMatch) {
                    fc.element.classList.add('locking'); // 啟動基礎鎖定 CSS

                    // 計算匹配比例
                    const totalLength = isEnglishMatch ? fc.englishKeys.length : fc.bopomofo.length;
                    const ratio = matchLength / totalLength;

                    // 判斷鎖定階段
                    if (ratio >= 0.5) {
                        // 匹配超過 50% -> 紅色高速旋轉
                        fc.element.classList.add('locking-stage-2');
                    } else {
                        // 匹配少於 50% -> 黃色正常旋轉
                        fc.element.classList.add('locking-stage-1');
                    }

                    // 文字高亮
                    if (isEnglishMatch) {
                        const matchedPart = fc.englishKeys.substring(0, matchLength);
                        const restPart = fc.englishKeys.substring(matchLength);
                        subTextEl.innerHTML = `${fc.bopomofo} <span class="opacity-70">[<span class="matched-highlight">${matchedPart}</span>${restPart}]</span>`;
                    } else {
                        const matchedPart = fc.bopomofo.substring(0, matchLength);
                        const restPart = fc.bopomofo.substring(matchLength);
                        subTextEl.innerHTML = `<span class="matched-highlight">${matchedPart}</span>${restPart} <span class="opacity-70">[${fc.englishKeys}]</span>`;
                    }
                } else {
                    // 無匹配
                    subTextEl.innerHTML = `${fc.bopomofo} <span class="opacity-70">[${fc.englishKeys}]</span>`;
                }
            });
        }
        
        function endGame(reason = "GAME OVER") {
            if (!gameActive) return;
            gameActive = false;
            
            if (turretResetTimeout) clearTimeout(turretResetTimeout);
            
            gameOverScreen.classList.remove('hidden');
            gameOverTitle.textContent = reason;
            
            finalCompletedElement.textContent = completedCount; 
            finalScoreElement.textContent = score.toString().padStart(6, '0');
            
            const rankInfo = calculateRank(score);
            saveScore(completedCount, score, missedCount);
            displayRankInfo(rankInfo.rank, rankInfo.isNewRecord, rankInfo.inTop10, rankInfo.highScore, score);
            displayTop10(score);
            
            charactersContainer.innerHTML = '';
            fallingCharacters = [];
            
            turretIcon.style.transform = 'rotate(-45deg)';
        }
        
        window.addEventListener('resize', () => {
            if (gameActive) {
                const containerWidth = charactersContainer.clientWidth;
                fallingCharacters.forEach(({ element }) => {
                    if (element.parentNode) {
                        let effectiveCharWidth = 80;
                        if (window.innerWidth <= 768) effectiveCharWidth = 70;
                        if (window.innerWidth <= 640) effectiveCharWidth = 65;
                        
                        const currentLeftPx = parseFloat(element.style.left);
                        const lastContainerWidth = parseFloat(element.dataset.lastContainerWidth || containerWidth);
                        
                        let newLeft;
                        if (element.dataset.lastContainerWidth && lastContainerWidth > 0) {
                            const currentLeftRatio = currentLeftPx / lastContainerWidth;
                            newLeft = currentLeftRatio * containerWidth;
                        } else {
                           newLeft = Math.random() * (containerWidth - effectiveCharWidth);
                        }
                        newLeft = Math.max(0, Math.min(newLeft, containerWidth - effectiveCharWidth));
                        element.style.left = `${newLeft}px`;
                        element.dataset.lastContainerWidth = containerWidth;
                    }
                });
            }
        });
    </script>
</body></html>
