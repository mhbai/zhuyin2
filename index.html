<html lang="zh-TW"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸­æ–‡æ³¨éŸ³æ‰“å­—éŠæˆ² - å°„æ“Šç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            overflow: hidden;
            height: 100vh;
            margin: 0;
            padding: 0;
        }
        
        .falling-character {
            position: absolute;
            animation-timing-function: linear;
            animation-fill-mode: forwards;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-weight: 700;
            transition: transform 0.2s, background 0.3s, box-shadow 0.3s;
            padding: 5px;
            text-align: center;
            z-index: 10;
        }
        
        .falling-character.locked {
            background: rgba(52, 211, 153, 0.3);
            box-shadow: 0 0 20px rgba(52, 211, 153, 0.6), 0 0 40px rgba(52, 211, 153, 0.4);
            border: 2px solid rgba(52, 211, 153, 0.8);
            transform: scale(1.1);
        }
        
        /* ç¨ç«‹çš„çˆ†ç‚¸æ•ˆæœé¡åˆ¥ */
        .explosion-effect {
            position: fixed; /* ä½¿ç”¨ fixed å®šä½ç¢ºä¿åº§æ¨™ç²¾æº– */
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            font-weight: 700;
            padding: 5px;
            text-align: center;
            user-select: none;
            /* çˆ†ç‚¸å‹•ç•« */
            animation: explode 0.4s ease-out forwards;
        }

        @keyframes explode {
            0% { transform: scale(1); opacity: 1; background: rgba(255, 255, 255, 0.8); }
            50% { transform: scale(1.5); opacity: 0.8; background: rgba(72, 219, 251, 1); box-shadow: 0 0 50px rgba(72, 219, 251, 0.8); }
            100% { transform: scale(2); opacity: 0; }
        }
        
        @keyframes fall {
            from { transform: translateY(-80px); }
            to { transform: translateY(100vh); }
        }
        
        /* é›·å°„å…‰æŸæ¨£å¼ */
        .laser-beam {
            position: absolute;
            height: 4px; /* é›·å°„ç²—ç´° */
            background: linear-gradient(90deg, rgba(255,255,255,0.8), #00ffff, rgba(0,255,255,0));
            transform-origin: 0 50%; /* å¾å·¦å´æ—‹è½‰ */
            box-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            border-radius: 2px;
        }

        /* ç ²å¡”æ¨£å¼ */
        .turret-container {
            position: absolute;
            bottom: 85px; /* åœ¨è¼¸å…¥æ¡†ä¸Šæ–¹ */
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            pointer-events: none;
        }
        
        .turret-icon {
            font-size: 3rem;
            color: #4fd1c5;
            text-shadow: 0 0 15px rgba(79, 209, 197, 0.6);
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.5));
            /* å¢åŠ å¹³æ»‘è½‰å‘éæ¸¡ */
            transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: block; /* ç¢ºä¿ transform æ­£å¸¸é‹ä½œ */
        }

        /* ç ²å¡”ç™¼å°„æ™‚çš„å¾Œåº§åŠ›å‹•ç•« */
        .turret-fire {
            animation: recoil 0.1s ease-in-out;
        }

        @keyframes recoil {
            0% { transform: translateY(0); }
            50% { transform: translateY(10px); }
            100% { transform: translateY(0); }
        }
        
        .input-area {
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.1);
            border-top: 2px solid rgba(255, 255, 255, 0.2); 
            z-index: 30;
        }
        
        #input-field {
            color: white;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            caret-color: #4fd1c5;
        }
        
        #input-field::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .game-over-overlay {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        @media (max-width: 768px) { 
            .falling-character { width: 70px; height: 70px; }
            .explosion-effect { width: 70px; height: 70px; }
            .turret-container { bottom: 75px; }
            .turret-icon { font-size: 2.5rem; }
        }

        @media (max-width: 640px) { 
            .falling-character { width: 65px; height: 65px; }
            .explosion-effect { width: 65px; height: 65px; }
            .turret-container { bottom: 70px; }
        }
    </style>
</head>
<body class="text-white">
    <!-- é–‹å§‹ç•«é¢ -->
    <div id="start-screen" class="fixed inset-0 flex flex-col items-center justify-center z-50 bg-gradient-to-br from-indigo-900 to-purple-900 p-4">
        <h1 class="text-4xl sm:text-5xl md:text-6xl font-bold mb-8 text-center text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">ä¸­æ–‡æ³¨éŸ³å°„æ“ŠéŠæˆ²</h1>
        <p class="text-lg sm:text-xl mb-8 text-center max-w-md px-4">è¼¸å…¥æ­£ç¢ºçš„æ³¨éŸ³ç¬¦è™Ÿæˆ–æŒ‰éµï¼Œå•Ÿå‹•é›·å°„ç ²å¡”æ¶ˆæ»…ç›®æ¨™ï¼<br><span class="text-sm text-gray-300 mt-2 block">(æ”¯æ´æ¨™æº–æ³¨éŸ³è¼¸å…¥æ³•èˆ‡ç›²æ‰“æŒ‰éµ)</span></p>
        <button id="start-button" class="px-6 py-3 sm:px-8 sm:py-4 bg-gradient-to-r from-blue-500 to-cyan-500 text-white text-lg sm:text-xl font-bold rounded-full hover:from-blue-600 hover:to-cyan-600 transition-all transform hover:scale-105 shadow-lg">é–‹å§‹ä»»å‹™</button>
    </div>

    <!-- éŠæˆ²ç•«é¢ -->
    <div id="game-container" class="hidden h-screen w-full relative">
        <!-- ç‹€æ…‹æ¬„ -->
        <div class="fixed top-0 left-0 right-0 p-2 sm:p-4 flex flex-wrap justify-around items-center gap-2 sm:gap-4 bg-black bg-opacity-30 backdrop-blur-sm z-40">
            <div class="bg-blue-900 bg-opacity-50 px-3 py-1 sm:px-4 sm:py-2 rounded-lg text-sm sm:text-base">
                <span class="font-medium">æ“Šè½æ•¸: </span>
                <span id="completed-count" class="text-base sm:text-lg font-bold text-cyan-400">0</span>
            </div>
            <div class="bg-purple-900 bg-opacity-50 px-3 py-1 sm:px-4 sm:py-2 rounded-lg text-sm sm:text-base">
                <span class="font-medium">åˆ†æ•¸: </span>
                <span id="score" class="text-base sm:text-lg font-bold text-yellow-400">0</span>
            </div>
            <div class="bg-red-900 bg-opacity-50 px-3 py-1 sm:px-4 sm:py-2 rounded-lg text-sm sm:text-base">
                <span class="font-medium">å…¥ä¾µ: </span>
                <span id="missed-count" class="text-base sm:text-lg font-bold text-red-400">0</span>
                <span class="font-medium"> / 5</span>
            </div>
            <div class="bg-gray-700 bg-opacity-50 px-2 py-1 sm:px-3 sm:py-1 rounded-lg text-xs sm:text-sm text-gray-300">
                <span class="hidden sm:inline">è¼¸å…¥ </span>quit<span class="hidden sm:inline"> çµæŸ</span>
            </div>
        </div>
        
        <div id="characters-container" class="w-full h-full"></div>
        
        <!-- ç ²å¡” -->
        <div id="turret" class="turret-container">
            <!-- åˆå§‹ç‹€æ…‹è¨­å®šç‚º -rotate-45ï¼Œä½¿å…¶æŒ‡å‘æ­£ä¸Šæ–¹ -->
            <i class="fas fa-rocket turret-icon transform -rotate-45"></i>
        </div>

        <div class="fixed bottom-0 left-0 right-0 p-2 sm:p-4 input-area">
            <div class="relative">
                <input type="text" id="input-field" class="w-full px-4 py-3 sm:px-6 sm:py-4 text-lg sm:text-xl bg-gray-800 bg-opacity-70 border-2 border-cyan-500 rounded-full text-white placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-cyan-400" placeholder="é–å®šç›®æ¨™ï¼Œè¼¸å…¥æ³¨éŸ³é–‹ç«..." autocomplete="off">
            </div>
        </div>
    </div>
    
    <div id="game-over" class="hidden fixed inset-0 flex flex-col items-center justify-center game-over-overlay z-50 p-4">
        <div class="bg-gradient-to-br from-gray-900 to-blue-900 p-6 sm:p-8 rounded-2xl max-w-md w-full border border-blue-500 shadow-2xl">
            <h2 id="game-over-title" class="text-2xl sm:text-3xl font-bold mb-4 text-center text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">ä»»å‹™çµæŸ</h2>
            <div class="space-y-3 sm:space-y-4 mb-6 text-base sm:text-lg">
                <p class="text-lg sm:text-xl text-center">æˆ°æœå ±å‘Šï¼š</p>
                <div class="flex justify-between items-center border-b border-gray-700 pb-2">
                    <span>æ“Šè½ç›®æ¨™ï¼š</span>
                    <span id="final-completed" class="font-bold text-cyan-400">0</span>
                </div>
                <div class="flex justify-between items-center border-b border-gray-700 pb-2">
                    <span>æœ€çµ‚å¾—åˆ†ï¼š</span>
                    <span id="final-score" class="font-bold text-yellow-400">0</span>
                </div>
                <div class="flex justify-between items-center border-b border-gray-700 pb-2">
                    <span>å…¥ä¾µæ¬¡æ•¸ï¼š</span>
                    <span id="final-missed" class="font-bold text-red-400">0</span>
                </div>
                <div class="flex justify-between items-center bg-gradient-to-r from-purple-900 to-blue-900 p-3 rounded-lg mt-4">
                    <span class="text-lg font-bold">ğŸ† æ’åï¼š</span>
                    <span id="rank-display" class="text-xl font-bold text-yellow-300">-</span>
                </div>
                <div id="high-score-display" class="text-center text-sm text-gray-400 mt-2"></div>
            </div>
            
            <div class="mb-6 bg-gray-900 bg-opacity-50 rounded-lg p-4">
                <h3 class="text-lg font-bold text-center mb-3 text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-400">ğŸ† ç‹ç‰Œé£›è¡Œå“¡</h3>
                <div id="top10-list" class="space-y-2 text-sm"></div>
            </div>
            <div class="flex justify-center">
                <button id="restart-button" class="px-4 py-2 sm:px-6 sm:py-3 bg-gradient-to-r from-blue-500 to-cyan-500 text-white text-base sm:text-lg font-bold rounded-full hover:from-blue-600 hover:to-cyan-600 transition-all transform hover:scale-105 shadow-lg">å†æ¬¡å‡ºæ“Š</button>
            </div>
        </div>
    </div>

    <script>
        const bopomofoKeyMap = {
            'ã„…': '1', 'ã„†': 'q', 'ã„‡': 'a', 'ã„ˆ': 'z', 'ã„‰': '2', 'ã„Š': 'w', 'ã„‹': 's', 'ã„Œ': 'x',
            'ã„': 'e', 'ã„': 'd', 'ã„': 'c', 'ã„': 'r', 'ã„‘': 'f', 'ã„’': 'v', 'ã„“': '5', 'ã„”': 't',
            'ã„•': 'g', 'ã„–': 'b', 'ã„—': 'y', 'ã„˜': 'h', 'ã„™': 'n', 'ã„§': 'u', 'ã„¨': 'j', 'ã„©': 'm',
            'ã„š': '8', 'ã„›': 'i', 'ã„œ': 'k', 'ã„': ',', 'ã„': '9', 'ã„Ÿ': 'o', 'ã„ ': 'l', 'ã„¡': '.',
            'ã„¢': '0', 'ã„£': 'p', 'ã„¤': ';', 'ã„¥': '/', 'ã„¦': '-',
            'ËŠ': '6', 'Ë‡': '3', 'Ë‹': '4', 'Ë™': '7'
        };

        const characterData = [
            { char: 'çš„', bopomofo: 'ã„‰ã„œË™' }, { char: 'ä¸€', bopomofo: 'ã„§' }, { char: 'æ˜¯', bopomofo: 'ã„•Ë‹' }, { char: 'ä¸', bopomofo: 'ã„…ã„¨Ë‹' },
            { char: 'äº†', bopomofo: 'ã„Œã„œË™' }, { char: 'æœ‰', bopomofo: 'ã„§ã„¡Ë‡' }, { char: 'å’Œ', bopomofo: 'ã„ã„œËŠ' }, { char: 'äºº', bopomofo: 'ã„–ã„£ËŠ' },
            { char: 'é€™', bopomofo: 'ã„“ã„œË‹' }, { char: 'ä¸­', bopomofo: 'ã„“ã„¨ã„¥' }, { char: 'å¤§', bopomofo: 'ã„‰ã„šË‹' }, { char: 'ç‚º', bopomofo: 'ã„¨ã„ŸËŠ' },
            { char: 'ä¸Š', bopomofo: 'ã„•ã„¤Ë‹' }, { char: 'å€‹', bopomofo: 'ã„ã„œË‹' }, { char: 'åœ‹', bopomofo: 'ã„ã„¨ã„›ËŠ' }, { char: 'æˆ‘', bopomofo: 'ã„¨ã„›Ë‡' },
            { char: 'ä»¥', bopomofo: 'ã„§Ë‡' }, { char: 'è¦', bopomofo: 'ã„§ã„ Ë‹' }, { char: 'ä»–', bopomofo: 'ã„Šã„š' }, { char: 'æ™‚', bopomofo: 'ã„•ËŠ' },
            { char: 'ä¾†', bopomofo: 'ã„Œã„ËŠ' }, { char: 'ç”¨', bopomofo: 'ã„©ã„¥Ë‹' }, { char: 'å€‘', bopomofo: 'ã„‡ã„£Ë™' }, { char: 'ç”Ÿ', bopomofo: 'ã„•ã„¥' },
            { char: 'åˆ°', bopomofo: 'ã„‰ã„ Ë‹' }, { char: 'ä½œ', bopomofo: 'ã„—ã„¨ã„›Ë‹' }, { char: 'åœ°', bopomofo: 'ã„‰ã„§Ë‹' }, { char: 'æ–¼', bopomofo: 'ã„©ËŠ' },
            { char: 'å‡º', bopomofo: 'ã„”ã„¨' }, { char: 'å°±', bopomofo: 'ã„ã„§ã„¡Ë‹' }, { char: 'åˆ†', bopomofo: 'ã„ˆã„£' }, { char: 'å°', bopomofo: 'ã„‰ã„¨ã„ŸË‹' },
            { char: 'æˆ', bopomofo: 'ã„”ã„¥ËŠ' }, { char: 'æœƒ', bopomofo: 'ã„ã„¨ã„ŸË‹' }, { char: 'å¯', bopomofo: 'ã„ã„œË‡' }, { char: 'ä¸»', bopomofo: 'ã„“ã„¨Ë‡' },
            { char: 'ç™¼', bopomofo: 'ã„ˆã„š' }, { char: 'å¹´', bopomofo: 'ã„‹ã„§ã„¢ËŠ' }, { char: 'å‹•', bopomofo: 'ã„‰ã„¨ã„¥Ë‹' }, { char: 'åŒ', bopomofo: 'ã„Šã„¨ã„¥ËŠ' },
            { char: 'å·¥', bopomofo: 'ã„ã„¨ã„¥' }, { char: 'ä¹Ÿ', bopomofo: 'ã„§ã„Ë‡' }, { char: 'èƒ½', bopomofo: 'ã„‹ã„¥ËŠ' }, { char: 'ä¸‹', bopomofo: 'ã„’ã„§ã„šË‹' },
            { char: 'é', bopomofo: 'ã„ã„¨ã„›Ë‹' }, { char: 'å­', bopomofo: 'ã„—Ë‡' }, { char: 'èªª', bopomofo: 'ã„•ã„¨ã„›' }, { char: 'ç”¢', bopomofo: 'ã„”ã„¢Ë‡' },
            { char: 'ç¨®', bopomofo: 'ã„“ã„¨ã„¥Ë‡' }, { char: 'é¢', bopomofo: 'ã„‡ã„§ã„¢Ë‹' }, { char: 'è€Œ', bopomofo: 'ã„¦ËŠ' }, { char: 'æ–¹', bopomofo: 'ã„ˆã„¤' },
            { char: 'å¾Œ', bopomofo: 'ã„ã„¡Ë‹' }, { char: 'å¤š', bopomofo: 'ã„‰ã„¨ã„›' }, { char: 'å®š', bopomofo: 'ã„‰ã„§ã„¥Ë‹' }, { char: 'è¡Œ', bopomofo: 'ã„’ã„§ã„¥ËŠ' },
            { char: 'å­¸', bopomofo: 'ã„’ã„©ã„ËŠ' }, { char: 'æ³•', bopomofo: 'ã„ˆã„šË‡' }, { char: 'æ‰€', bopomofo: 'ã„™ã„¨ã„›Ë‡' }, { char: 'æ°‘', bopomofo: 'ã„‡ã„§ã„£ËŠ' },
            { char: 'å¾—', bopomofo: 'ã„‰ã„œËŠ' }, { char: 'ç¶“', bopomofo: 'ã„ã„§ã„¥' }, { char: 'å', bopomofo: 'ã„•ËŠ' }, { char: 'ä¸‰', bopomofo: 'ã„™ã„¢' },
            { char: 'ä¹‹', bopomofo: 'ã„“' }, { char: 'é€²', bopomofo: 'ã„ã„§ã„£Ë‹' }, { char: 'è‘—', bopomofo: 'ã„“ã„œË™' }, { char: 'ç­‰', bopomofo: 'ã„‰ã„¥Ë‡' },
            { char: 'éƒ¨', bopomofo: 'ã„…ã„¨Ë‹' }, { char: 'åº¦', bopomofo: 'ã„‰ã„¨Ë‹' }, { char: 'å®¶', bopomofo: 'ã„ã„§ã„š' }, { char: 'é›»', bopomofo: 'ã„‰ã„§ã„¢Ë‹' },
            { char: 'åŠ›', bopomofo: 'ã„Œã„§Ë‹' }, { char: 'è£¡', bopomofo: 'ã„Œã„§Ë‡' }, { char: 'å¦‚', bopomofo: 'ã„–ã„¨ËŠ' }, { char: 'æ°´', bopomofo: 'ã„•ã„¨ã„ŸË‡' },
            { char: 'åŒ–', bopomofo: 'ã„ã„¨ã„šË‹' }, { char: 'é«˜', bopomofo: 'ã„ã„ ' }, { char: 'è‡ª', bopomofo: 'ã„—Ë‹' }, { char: 'äºŒ', bopomofo: 'ã„¦Ë‹' },
            { char: 'ç†', bopomofo: 'ã„Œã„§Ë‡' }, { char: 'èµ·', bopomofo: 'ã„‘ã„§Ë‡' }, { char: 'å°', bopomofo: 'ã„’ã„§ã„ Ë‡' }, { char: 'ç‰©', bopomofo: 'ã„¨Ë‹' },
            { char: 'ç¾', bopomofo: 'ã„’ã„§ã„¢Ë‹' }, { char: 'å¯¦', bopomofo: 'ã„•ËŠ' }, { char: 'åŠ ', bopomofo: 'ã„ã„§ã„š' }, { char: 'é‡', bopomofo: 'ã„Œã„§ã„¤Ë‹' },
            { char: 'éƒ½', bopomofo: 'ã„‰ã„¡' }, { char: 'å…©', bopomofo: 'ã„Œã„§ã„¤Ë‡' }, { char: 'é«”', bopomofo: 'ã„Šã„§Ë‡' }, { char: 'åˆ¶', bopomofo: 'ã„“Ë‹' },
            { char: 'æ©Ÿ', bopomofo: 'ã„ã„§' }, { char: 'ç•¶', bopomofo: 'ã„‰ã„¤' }, { char: 'ä½¿', bopomofo: 'ã„•Ë‡' }, { char: 'é»', bopomofo: 'ã„‰ã„§ã„¢Ë‡' },
            { char: 'å¾', bopomofo: 'ã„˜ã„¨ã„¥ËŠ' }, { char: 'æ¥­', bopomofo: 'ã„§ã„Ë‹' }, { char: 'æœ¬', bopomofo: 'ã„…ã„£Ë‡' }, { char: 'å»', bopomofo: 'ã„‘ã„©Ë‹' },
            { char: 'æŠŠ', bopomofo: 'ã„…ã„šË‡' }, { char: 'é•·', bopomofo: 'ã„“ã„¤Ë‡' }, { char: 'è¦‹', bopomofo: 'ã„ã„§ã„¢Ë‹' }, { char: 'å·±', bopomofo: 'ã„ã„§Ë‡' },
            { char: 'é‡', bopomofo: 'ã„“ã„¨ã„¥Ë‹' }, { char: 'æ­¤', bopomofo: 'ã„˜Ë‡' }, { char: 'é–“', bopomofo: 'ã„ã„§ã„¢' }, { char: 'å‘', bopomofo: 'ã„’ã„§ã„¤Ë‹' },
            { char: 'é“', bopomofo: 'ã„‰ã„ Ë‹' }, { char: 'å‘½', bopomofo: 'ã„‡ã„§ã„¥Ë‹' }, { char: 'æƒ³', bopomofo: 'ã„’ã„§ã„¤Ë‡' }, { char: 'æƒ…', bopomofo: 'ã„‘ã„§ã„¥ËŠ' },
            { char: 'äº‹', bopomofo: 'ã„•Ë‹' }, { char: 'çŸ¥', bopomofo: 'ã„“' }, { char: 'è€…', bopomofo: 'ã„“ã„œË‡' }, { char: 'çµ¦', bopomofo: 'ã„ã„ŸË‡' },
            { char: 'æ¬¡', bopomofo: 'ã„˜Ë‹' }, { char: 'ä½ ', bopomofo: 'ã„‹ã„§Ë‡' }, { char: 'å¥½', bopomofo: 'ã„ã„ Ë‡' }, { char: 'æœ‹', bopomofo: 'ã„†ã„¥ËŠ' },
            { char: 'å‹', bopomofo: 'ã„§ã„¡Ë‡' }, { char: 'å¥¹', bopomofo: 'ã„Šã„š' }, { char: 'å¿«', bopomofo: 'ã„ã„¨ã„Ë‹' }, { char: 'æ¨‚', bopomofo: 'ã„Œã„œË‹' },
            { char: 'æ„›', bopomofo: 'ã„Ë‹' }, { char: 'å…‰', bopomofo: 'ã„ã„¨ã„¤' }, { char: 'é¢¨', bopomofo: 'ã„ˆã„¥' }, { char: 'èŠ±', bopomofo: 'ã„ã„¨ã„š' },
            { char: 'å±±', bopomofo: 'ã„•ã„¢' }, { char: 'å¤©', bopomofo: 'ã„Šã„§ã„¢' }, { char: 'é³¥', bopomofo: 'ã„‹ã„§ã„ Ë‡' },
            { char: 'é­š', bopomofo: 'ã„©ËŠ' }, { char: 'æ›¸', bopomofo: 'ã„•ã„¨' }, { char: 'çœ‹', bopomofo: 'ã„ã„¢Ë‹' }, { char: 'è½', bopomofo: 'ã„Šã„§ã„¥' }
        ];

        function convertBopomofoToEnglish(bopomofo) {
            const tones = ['ËŠ', 'Ë‡', 'Ë‹', 'Ë™'];
            let keyString = '';
            let hasTone = false;
            for (const char of bopomofo) {
                if (bopomofoKeyMap[char]) {
                    keyString += bopomofoKeyMap[char];
                    if (tones.includes(char)) {
                        hasTone = true;
                    }
                }
            }
            if (!hasTone) {
                keyString += ' '; // ä¸€è²ä»¥ç©ºç™½éµçµå°¾
            }
            return keyString;
        }

        const characterDataWithKeys = characterData.map(data => ({
            ...data,
            englishKeys: convertBopomofoToEnglish(data.bopomofo)
        }));

        let gameActive = false;
        let fallingCharacters = [];
        let completedCount = 0;
        let score = 0;
        let missedCount = 0; 
        let maxMisses = 5;
        let isComposing = false;
        
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameContainer = document.getElementById('game-container');
        const charactersContainer = document.getElementById('characters-container');
        const inputField = document.getElementById('input-field');
        const completedCountElement = document.getElementById('completed-count');
        const scoreElement = document.getElementById('score');
        const missedCountElement = document.getElementById('missed-count');
        const gameOverScreen = document.getElementById('game-over');
        const gameOverTitle = document.getElementById('game-over-title');
        const finalCompletedElement = document.getElementById('final-completed');
        const finalScoreElement = document.getElementById('final-score');
        const finalMissedElement = document.getElementById('final-missed');
        const rankDisplayElement = document.getElementById('rank-display');
        const highScoreDisplayElement = document.getElementById('high-score-display');
        const top10ListElement = document.getElementById('top10-list');
        const restartButton = document.getElementById('restart-button');
        const turretElement = document.getElementById('turret');
        const turretIcon = turretElement.querySelector('i');
        
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        
        function getRandomUniqueCharacter() {
            const onScreenChars = fallingCharacters.map(fc => fc.char);
            let availableCharsData = characterDataWithKeys.filter(data => !onScreenChars.includes(data.char));
            if (availableCharsData.length === 0) {
                availableCharsData = [...characterDataWithKeys];
            }
            const randomIndex = Math.floor(Math.random() * availableCharsData.length);
            return availableCharsData[randomIndex];
        }

        function getCurrentMaxCharacters() {
            return Math.floor(completedCount / 20) + 1;
        }

        function saveScore(completed, score, missed) {
            const scoreData = {
                completed: completed,
                score: score,
                missed: missed,
                date: new Date().toISOString(),
                timestamp: Date.now()
            };
            let scores = getScores();
            scores.push(scoreData);
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 10);
            localStorage.setItem('typingGameScores', JSON.stringify(scores));
            return scoreData;
        }
        
        function getScores() {
            const stored = localStorage.getItem('typingGameScores');
            return stored ? JSON.parse(stored) : [];
        }
        
        function calculateRank(currentScore) {
            const scores = getScores();
            if (scores.length === 0) return { rank: 1, isNewRecord: false, inTop10: true, highScore: null };
            const sortedScores = [...scores].sort((a, b) => b.score - a.score);
            const highScore = sortedScores[0].score;
            let rank = 1;
            for (let i = 0; i < sortedScores.length; i++) {
                if (currentScore > sortedScores[i].score) {
                    rank = i + 1;
                    break;
                } else if (i === sortedScores.length - 1) {
                    rank = sortedScores.length + 1;
                }
            }
            return { rank: rank, isNewRecord: currentScore > highScore, inTop10: rank <= 10, highScore: highScore };
        }
        
        function displayRankInfo(rank, isNewRecord, inTop10, highScore, currentScore) {
            if (inTop10) {
                rankDisplayElement.textContent = `ç¬¬ ${rank} å`;
            } else {
                rankDisplayElement.textContent = 'æœªä¸Šæ¦œ';
            }
            
            if (rank === 1 && !highScore) {
                highScoreDisplayElement.innerHTML = '<span class="text-cyan-400">ç‹ç‰Œé£›è¡Œå“¡èª•ç”Ÿï¼</span>';
            } else if (isNewRecord) {
                highScoreDisplayElement.innerHTML = '<span class="text-yellow-400 font-bold">ğŸ‰ æ­å–œï¼å‰µé€ æ–°ç´€éŒ„ï¼</span>';
            } else if (inTop10) {
                const difference = highScore - currentScore;
                highScoreDisplayElement.innerHTML = `<span class="text-gray-400">æœ€é«˜åˆ†ï¼š${highScore} åˆ†</span><br><span class="text-sm text-gray-500">è·é›¢æœ€é«˜åˆ†é‚„å·® ${difference} åˆ†</span>`;
            } else {
                const scores = getScores();
                const lowestTop10Score = scores[Math.min(9, scores.length - 1)]?.score || 0;
                const difference = lowestTop10Score - currentScore + 1;
                highScoreDisplayElement.innerHTML = `<span class="text-gray-400">ç¹¼çºŒåŠ æ²¹ï¼</span><br><span class="text-sm text-gray-500">è·é›¢ TOP 10 é‚„å·® ${difference} åˆ†</span>`;
            }
        }
        
        function getTop10Scores() {
            const scores = getScores();
            return [...scores].sort((a, b) => b.score - a.score).slice(0, 10);
        }
        
        function formatDate(isoString) {
            const date = new Date(isoString);
            return `${date.getMonth() + 1}/${date.getDate()} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
        }
        
        function displayTop10(currentScore) {
            const top10 = getTop10Scores();
            if (top10.length === 0) {
                top10ListElement.innerHTML = '<p class="text-center text-gray-400">æš«ç„¡é£›è¡Œç´€éŒ„</p>';
                return;
            }
            
            let html = '';
            top10.forEach((scoreData, index) => {
                const rank = index + 1;
                const isCurrentScore = Math.abs(scoreData.timestamp - Date.now()) < 1000;
                const bgClass = isCurrentScore ? 'bg-gradient-to-r from-yellow-900 to-orange-900 border border-yellow-500' : 'bg-gray-800 bg-opacity-50';
                const medalEmoji = rank === 1 ? 'ğŸ¥‡' : rank === 2 ? 'ğŸ¥ˆ' : rank === 3 ? 'ğŸ¥‰' : `${rank}.`;
                
                html += `
                    <div class="${bgClass} p-2 rounded flex justify-between items-center">
                        <div class="flex items-center gap-2 flex-1">
                            <span class="font-bold ${rank <= 3 ? 'text-lg' : ''}">${medalEmoji}</span>
                            <div class="flex-1">
                                <div class="flex justify-between">
                                    <span class="font-bold text-yellow-400">${scoreData.score} åˆ†</span>
                                    <span class="text-xs text-gray-400">${formatDate(scoreData.date)}</span>
                                </div>
                                <div class="text-xs text-gray-300">
                                    æ“Šè½ ${scoreData.completed} | å…¥ä¾µ ${scoreData.missed}
                                </div>
                            </div>
                        </div>
                        ${isCurrentScore ? '<span class="text-yellow-400 text-xs ml-2">â† æœ¬æ¬¡</span>' : ''}
                    </div>
                `;
            });
            top10ListElement.innerHTML = html;
        }

        function spawnNewCharacter() {
            if (!gameActive) return;

            const maxChars = getCurrentMaxCharacters();
            if (fallingCharacters.length >= maxChars) return;

            const charData = getRandomUniqueCharacter();
            if (!charData) return; 

            const charElement = document.createElement('div');
            charElement.className = 'falling-character';
            charElement.innerHTML = `<span class="text-2xl">${charData.char}</span><span class="text-xs text-cyan-300 mt-1">${charData.bopomofo} (${charData.englishKeys})</span>`;
            
            charElement.dataset.char = charData.char;
            charElement.dataset.bopomofo = charData.bopomofo;
            charElement.dataset.englishKeys = charData.englishKeys;

            const containerWidth = charactersContainer.clientWidth;
            let effectiveCharWidth = 80;
            if (window.innerWidth <= 768) effectiveCharWidth = 70;
            if (window.innerWidth <= 640) effectiveCharWidth = 65;

            const left = Math.random() * (containerWidth - effectiveCharWidth);
            charElement.style.left = `${Math.max(0, left)}px`;

            const duration = 15 + Math.random() * 10;
            charElement.style.animationName = 'fall';
            charElement.style.animationDuration = `${duration}s`;

            charactersContainer.appendChild(charElement);

            const newFcData = {
                element: charElement,
                char: charData.char,
                bopomofo: charData.bopomofo,
                englishKeys: charData.englishKeys,
                duration: duration,
                startTime: Date.now(),
                isHit: false 
            };
            fallingCharacters.push(newFcData);

            charElement.addEventListener('animationend', function handleAnimationEnd(e) {
                this.removeEventListener('animationend', handleAnimationEnd);
                const index = fallingCharacters.findIndex(fc => fc.element === this);
                
                // åªæœ‰æ²’è¢«æ“Šä¸­çš„æ‰ç®—miss
                if (index > -1 && !fallingCharacters[index].isHit) {
                    fallingCharacters.splice(index, 1);
                    if (this.parentNode) {
                        this.parentNode.removeChild(this);
                    }
                    
                    if (gameActive) {
                        missedCount++;
                        missedCountElement.textContent = missedCount;
                        
                        if (missedCount >= maxMisses) {
                            endGame("ä»»å‹™å¤±æ•—");
                            return;
                        }
                        
                        const maxChars = getCurrentMaxCharacters();
                        while (fallingCharacters.length < maxChars && gameActive) {
                            spawnNewCharacter();
                        }
                    }
                }
            });
        }

        function startGame() {
            startScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            gameOverScreen.classList.add('hidden');
            
            gameActive = true;
            completedCount = 0;
            score = 0;
            missedCount = 0;
            fallingCharacters = [];
            charactersContainer.innerHTML = ''; 
            
            completedCountElement.textContent = completedCount;
            scoreElement.textContent = score;
            missedCountElement.textContent = missedCount;
            
            inputField.focus();
            inputField.value = '';
            updateTargetLocking('');
            setupInputListeners();
            
            // é‡ç½®ç ²å¡”
            turretIcon.style.transform = 'rotate(-45deg)';

            const maxChars = getCurrentMaxCharacters();
            for (let i = 0; i < maxChars; i++) {
                spawnNewCharacter();
            }
        }
        
        let turretResetTimeout; // ç”¨æ–¼å„²å­˜è‡ªå‹•æ­¸ä½çš„ timer

        // å°„æ“Šé›·å°„å‡½æ•¸
        function fireLaser(targetFc) {
            const turretRect = turretIcon.getBoundingClientRect();
            // æ³¨æ„ï¼šå› ç‚ºæˆ‘å€‘ä½¿ç”¨äº† Explosion Proxyï¼ŒåŸæœ¬çš„ targetFc.element å¯èƒ½å·²ç¶“è¢«ç§»é™¤æˆ–æ­£åœ¨è¢«ç§»é™¤
            // åœ¨ fireLaser è¢«å‘¼å«æ™‚ï¼Œelement æ‡‰è©²é‚„åœ¨ã€‚ç¢ºä¿å–å¾—æ­£ç¢ºåº§æ¨™ã€‚
            const targetRect = targetFc.element.getBoundingClientRect();
            
            // ç ²å¡”ä¸­å¿ƒ
            const startX = turretRect.left + turretRect.width / 2;
            const startY = turretRect.top + turretRect.height / 2;
            
            // ç›®æ¨™ä¸­å¿ƒ
            const endX = targetRect.left + targetRect.width / 2;
            const endY = targetRect.top + targetRect.height / 2;
            
            // è¨ˆç®—è§’åº¦å’Œè·é›¢
            const deltaX = endX - startX;
            const deltaY = endY - startY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
            
            // ä¿®æ­£ç ²å¡”æ—‹è½‰è§’åº¦ï¼šç«ç®­é è¨­æ˜¯æœå³ä¸Š (45åº¦)ï¼Œæ‰€ä»¥è¦ +45 ä¿®æ­£ç‚º 0 åº¦åŸºæº–
            const rotation = angle + 45;

            // æ¸…é™¤ä¹‹å‰çš„æ­¸ä½ timerï¼Œé¿å…è¡çª
            if (turretResetTimeout) clearTimeout(turretResetTimeout);

            // æ—‹è½‰ç ²å¡”åœ–ç¤º
            turretIcon.style.transform = `rotate(${rotation}deg)`; 
            turretIcon.parentElement.classList.remove('turret-fire');
            void turretIcon.parentElement.offsetWidth; // è§¸ç™¼é‡ç¹ª
            turretIcon.parentElement.classList.add('turret-fire');

            // è¨­å®šè‡ªå‹•æ­¸ä½
            turretResetTimeout = setTimeout(() => {
                if (gameActive) {
                     turretIcon.style.transform = 'rotate(-45deg)';
                }
            }, 600); // 0.6ç§’å¾Œæ­¸ä½

            // å‰µå»ºé›·å°„å…‰æŸ
            const laser = document.createElement('div');
            laser.className = 'laser-beam';
            laser.style.width = `${distance}px`;
            laser.style.left = `${startX}px`;
            laser.style.top = `${startY}px`;
            laser.style.transform = `rotate(${angle}deg)`;
            
            document.body.appendChild(laser);
            
            // é›·å°„å‹•ç•«
            const anim = laser.animate([
                { width: '0px', opacity: 0.8 },
                { width: `${distance}px`, opacity: 1 },
                { width: `${distance}px`, opacity: 0 }
            ], {
                duration: 200,
                easing: 'ease-out'
            });
            
            anim.onfinish = () => {
                laser.remove();
                triggerExplosion(targetFc);
            };
        }

        // è§¸ç™¼çˆ†ç‚¸èˆ‡åŠ åˆ†
        function triggerExplosion(fc) {
            // 1. å–å¾—ç›®æ¨™ç•¶å‰çš„è¢å¹•åº§æ¨™
            const rect = fc.element.getBoundingClientRect();
            
            // 2. å‰µå»ºæ›¿èº«å…ƒç´  (Explosion Proxy)
            const explosion = document.createElement('div');
            explosion.className = 'explosion-effect'; 
            explosion.innerHTML = fc.element.innerHTML;
            
            // è¨­å®šæ›¿èº«çš„ä½ç½®å®Œå…¨é‡ç–Šåœ¨åŸæœ¬ç›®æ¨™ä¸Š
            explosion.style.left = rect.left + 'px';
            explosion.style.top = rect.top + 'px';
            explosion.style.backgroundColor = 'rgba(72, 219, 251, 0.8)';
            
            // 3. ç«‹å³ç§»é™¤åŸæœ¬çš„ä¸‹å¢œç›®æ¨™
            fc.element.remove();
            
            document.body.appendChild(explosion);
            
            explosion.addEventListener('animationend', () => {
                explosion.remove();
            });
            
            const elapsedTime = (Date.now() - fc.startTime) / 1000;
            const speedBonus = Math.max(1, Math.floor(10 - elapsedTime * 0.5));
            const pointsEarned = 50 + speedBonus * 5;
            
            score += pointsEarned;
            scoreElement.textContent = score;
            
            const pointsIndicator = document.createElement('div');
            pointsIndicator.textContent = `+${pointsEarned}`;
            pointsIndicator.className = 'absolute text-yellow-300 font-bold text-lg sm:text-xl z-30';
            pointsIndicator.style.left = `${rect.left + window.scrollX}px`;
            pointsIndicator.style.top = `${rect.top + window.scrollY}px`;
            pointsIndicator.style.animation = 'fadeUpAndOut 1s forwards ease-out';
            document.body.appendChild(pointsIndicator);
            setTimeout(() => pointsIndicator.remove(), 950);
            
            const fcIndex = fallingCharacters.findIndex(item => item === fc);
            if (fcIndex !== -1) {
                fallingCharacters.splice(fcIndex, 1);
            }
            
            completedCount++;
            completedCountElement.textContent = completedCount;
            
            if (gameActive) {
                const maxChars = getCurrentMaxCharacters();
                while (fallingCharacters.length < maxChars && gameActive) {
                    spawnNewCharacter();
                }
            }
        }

        let inputListenersSetup = false;
        
        function setupInputListeners() {
            if (inputListenersSetup) return;

            const inputHandler = (e) => {
                if (!isComposing) {
                    const inputValue = e.target.value;
                    
                    if (inputValue.toLowerCase() === 'quit') {
                        const confirmed = confirm('ç¢ºå®šè¦çµæŸä»»å‹™å—ï¼Ÿç›®å‰çš„æˆç¸¾æœƒè¢«è¨˜éŒ„ã€‚');
                        if (confirmed) {
                            endGame('ä»»å‹™ä¸­æ­¢');
                        }
                        inputField.value = '';
                        updateTargetLocking('');
                        return;
                    }
                    
                    updateTargetLocking(inputValue);
                    processInput(inputValue);
                    
                    const toneKeys = ['3', '4', '6', '7'];
                    const lastChar = inputValue.slice(-1);
                    if (toneKeys.includes(lastChar)) {
                        setTimeout(() => {
                            if (!isComposing) {
                                inputField.value = '';
                                updateTargetLocking('');
                            }
                        }, 10);
                    }
                }
            };

            const compositionStartHandler = () => { isComposing = true; };
            const compositionUpdateHandler = (e) => { if (e.data) updateTargetLocking(e.data); };
            const compositionEndHandler = (e) => {
                isComposing = false;
                processInput(e.data || e.target.value);
                setTimeout(() => {
                    if (inputField.value === (e.data || e.target.value)) {
                       inputField.value = '';
                       updateTargetLocking('');
                    }
                }, 0);
            };
            
            const keyDownHandler = (e) => {
                if (e.key === ' ') {
                    const currentInput = e.target.value;
                    if (!currentInput) return;
                    const potentialMatch = currentInput + ' ';
                    const targetFc = findMatchingChar(potentialMatch);
                    e.preventDefault();
                    if (targetFc) {
                        handleHitLogic(targetFc);
                    }
                    inputField.value = '';
                    updateTargetLocking('');
                }
            };

            inputField.removeEventListener('input', inputHandler);
            inputField.removeEventListener('keydown', keyDownHandler);
            inputField.removeEventListener('compositionstart', compositionStartHandler);
            inputField.removeEventListener('compositionupdate', compositionUpdateHandler);
            inputField.removeEventListener('compositionend', compositionEndHandler);

            inputField.addEventListener('input', inputHandler);
            inputField.addEventListener('keydown', keyDownHandler);
            inputField.addEventListener('compositionstart', compositionStartHandler);
            inputField.addEventListener('compositionupdate', compositionUpdateHandler);
            inputField.addEventListener('compositionend', compositionEndHandler);

            inputListenersSetup = true;
        }

        function findMatchingChar(typedValue) {
            let targetFc = null;
            let maxProgress = -1;

            for (const fc of fallingCharacters) {
                if (fc.isHit) continue;
                
                if ((fc.bopomofo === typedValue || fc.char === typedValue || fc.englishKeys.toLowerCase() === typedValue.toLowerCase()) && fc.element.parentNode) {
                    const elapsedTime = (Date.now() - fc.startTime) / 1000;
                    const progress = elapsedTime / fc.duration;
                    if (progress > maxProgress) {
                        maxProgress = progress;
                        targetFc = fc;
                    }
                }
            }
            return targetFc;
        }

        function handleHitLogic(fc) {
            if (fc.isHit) return;
            fc.isHit = true;
            fc.element.classList.remove('locked');
            fireLaser(fc);
        }
        
        function processInput(inputValue) {
            if (!inputValue || !gameActive) return;
            const targetFc = findMatchingChar(inputValue);

            if (targetFc) {
                handleHitLogic(targetFc);
                if (!isComposing) {
                    inputField.value = '';
                }
            }
        }
        
        function updateTargetLocking(inputValue) {
            fallingCharacters.forEach(fc => {
                if (!fc.element.parentNode || fc.isHit) return;
                
                const isMatch = inputValue && (
                    fc.englishKeys.toLowerCase().startsWith(inputValue.toLowerCase()) ||
                    fc.bopomofo.startsWith(inputValue)
                );
                
                if (isMatch) {
                    fc.element.classList.add('locked');
                } else {
                    fc.element.classList.remove('locked');
                }
            });
            
            if (!inputValue) {
                fallingCharacters.forEach(fc => {
                    if (fc.element.parentNode) {
                        fc.element.classList.remove('locked');
                    }
                });
            }
        }
        
        function endGame(reason = "ä»»å‹™çµæŸ") {
            if (!gameActive) return;
            gameActive = false;
            
            if (turretResetTimeout) clearTimeout(turretResetTimeout);
            
            gameOverScreen.classList.remove('hidden');
            gameOverTitle.textContent = reason;
            
            finalCompletedElement.textContent = completedCount; 
            finalScoreElement.textContent = score;
            finalMissedElement.textContent = missedCount;
            
            const rankInfo = calculateRank(score);
            saveScore(completedCount, score, missedCount);
            displayRankInfo(rankInfo.rank, rankInfo.isNewRecord, rankInfo.inTop10, rankInfo.highScore, score);
            displayTop10(score);
            
            charactersContainer.innerHTML = '';
            fallingCharacters = [];
            
            turretIcon.style.transform = 'rotate(-45deg)';
        }
        
        const styleSheet = document.createElement('style');
        styleSheet.textContent = `
            @keyframes fadeUpAndOut {
                0% { opacity: 1; transform: translateY(0) scale(0.8); }
                70% { opacity: 0.8; transform: translateY(-40px) scale(1.1); }
                100% { opacity: 0; transform: translateY(-60px) scale(0.5); }
            }
        `;
        document.head.appendChild(styleSheet);
        
        window.addEventListener('resize', () => {
            if (gameActive) {
                const containerWidth = charactersContainer.clientWidth;
                fallingCharacters.forEach(({ element }) => {
                    if (element.parentNode) {
                        let effectiveCharWidth = 80;
                        if (window.innerWidth <= 768) effectiveCharWidth = 70;
                        if (window.innerWidth <= 640) effectiveCharWidth = 65;
                        
                        const currentLeftPx = parseFloat(element.style.left);
                        const lastContainerWidth = parseFloat(element.dataset.lastContainerWidth || containerWidth);
                        
                        let newLeft;
                        if (element.dataset.lastContainerWidth && lastContainerWidth > 0) {
                            const currentLeftRatio = currentLeftPx / lastContainerWidth;
                            newLeft = currentLeftRatio * containerWidth;
                        } else {
                           newLeft = Math.random() * (containerWidth - effectiveCharWidth);
                        }
                        newLeft = Math.max(0, Math.min(newLeft, containerWidth - effectiveCharWidth));
                        element.style.left = `${newLeft}px`;
                        element.dataset.lastContainerWidth = containerWidth;
                    }
                });
            }
        });
    </script>
</body></html>
