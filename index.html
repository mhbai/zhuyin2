<html lang="zh-TW"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸­æ–‡æ³¨éŸ³æ‰“å­—éŠæˆ²</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            overflow: hidden; /* Prevent scrollbars from falling characters */
            height: 100vh;
            margin: 0;
            padding: 0;
        }
        
        .falling-character {
            position: absolute;
            animation-timing-function: linear;
            animation-fill-mode: forwards;
            user-select: none;
            display: flex;
            flex-direction: column; /* è®“å­—å’Œæ³¨éŸ³å‚ç›´æ’åˆ— */
            align-items: center;
            justify-content: center;
            width: 80px; /* åŠ å¯¬ä»¥å®¹ç´æŒ‰éµæç¤º */
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-weight: 700;
            transition: transform 0.2s, opacity 0.2s, background 0.3s, box-shadow 0.3s;
            padding: 5px;
            text-align: center;
        }
        
        .falling-character.locked {
            background: rgba(52, 211, 153, 0.3);
            box-shadow: 0 0 20px rgba(52, 211, 153, 0.6), 0 0 40px rgba(52, 211, 153, 0.4);
            border: 2px solid rgba(52, 211, 153, 0.8);
            transform: scale(1.1);
        }
        
        .falling-character.hit {
            transform: scale(1.5);
            opacity: 0;
            background: rgba(72, 219, 251, 0.8);
        }
        
        @keyframes fall {
            from {
                transform: translateY(-80px); /* Start above screen */
            }
            to {
                transform: translateY(100vh); /* Fall to bottom of screen */
            }
        }
        
        .input-area {
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.1);
            border-top: 2px solid rgba(255, 255, 255, 0.2); 
        }
        
        #input-field {
            color: white;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            caret-color: #4fd1c5;
        }
        
        #input-field::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .game-over-overlay {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        @media (max-width: 768px) { 
            .falling-character {
                width: 70px;
                height: 70px;
            }
        }

        @media (max-width: 640px) { 
            .falling-character {
                width: 65px;
                height: 65px;
            }
        }
    </style>
</head>
<body class="text-white">
    <!-- é–‹å§‹ç•«é¢ -->
    <div id="start-screen" class="fixed inset-0 flex flex-col items-center justify-center z-50 bg-gradient-to-br from-indigo-900 to-purple-900 p-4">
        <h1 class="text-4xl sm:text-5xl md:text-6xl font-bold mb-8 text-center text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">ä¸­æ–‡æ³¨éŸ³æ‰“å­—éŠæˆ²</h1>
        <p class="text-lg sm:text-xl mb-8 text-center max-w-md px-4">æŒ‘æˆ°ä½ çš„ä¸­æ–‡æ³¨éŸ³æ‰“å­—é€Ÿåº¦ï¼è¼¸å…¥æ­£ç¢ºçš„æ³¨éŸ³ç¬¦è™Ÿæˆ–å°æ‡‰æŒ‰éµä¾†æ¶ˆæ»…å¾å¤©è€Œé™çš„å­—å…ƒã€‚</p>
        <button id="start-button" class="px-6 py-3 sm:px-8 sm:py-4 bg-gradient-to-r from-blue-500 to-cyan-500 text-white text-lg sm:text-xl font-bold rounded-full hover:from-blue-600 hover:to-cyan-600 transition-all transform hover:scale-105 shadow-lg">é–‹å§‹éŠæˆ²</button>
    </div>

    <!-- éŠæˆ²ç•«é¢ -->
    <div id="game-container" class="hidden h-screen w-full relative">
        <!-- ç‹€æ…‹æ¬„ -->
        <div class="fixed top-0 left-0 right-0 p-2 sm:p-4 flex flex-wrap justify-around items-center gap-2 sm:gap-4 bg-black bg-opacity-30 backdrop-blur-sm z-10">
            <div class="bg-blue-900 bg-opacity-50 px-3 py-1 sm:px-4 sm:py-2 rounded-lg text-sm sm:text-base">
                <span class="font-medium">å·²å®Œæˆ: </span>
                <span id="completed-count" class="text-base sm:text-lg font-bold text-cyan-400">0</span>
            </div>
            <div class="bg-purple-900 bg-opacity-50 px-3 py-1 sm:px-4 sm:py-2 rounded-lg text-sm sm:text-base">
                <span class="font-medium">åˆ†æ•¸: </span>
                <span id="score" class="text-base sm:text-lg font-bold text-yellow-400">0</span>
            </div>
            <div class="bg-red-900 bg-opacity-50 px-3 py-1 sm:px-4 sm:py-2 rounded-lg text-sm sm:text-base">
                <span class="font-medium">éºæ¼: </span>
                <span id="missed-count" class="text-base sm:text-lg font-bold text-red-400">0</span>
                <span class="font-medium"> / 5</span>
            </div>
            <div class="bg-gray-700 bg-opacity-50 px-2 py-1 sm:px-3 sm:py-1 rounded-lg text-xs sm:text-sm text-gray-300">
                <span class="hidden sm:inline">è¼¸å…¥ </span>quit<span class="hidden sm:inline"> çµæŸ</span>
            </div>
        </div>
        
        <div id="characters-container" class="w-full h-full"></div>
        
        <div class="fixed bottom-0 left-0 right-0 p-2 sm:p-4 input-area">
            <div class="relative">
                <input type="text" id="input-field" class="w-full px-4 py-3 sm:px-6 sm:py-4 text-lg sm:text-xl bg-gray-800 bg-opacity-70 border-2 border-cyan-500 rounded-full text-white placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-cyan-400" placeholder="è«‹ç›´æ¥è¼¸å…¥æ³¨éŸ³æˆ–å°æ‡‰æŒ‰éµ..." autocomplete="off">
            </div>
        </div>
    </div>
    
    <div id="game-over" class="hidden fixed inset-0 flex flex-col items-center justify-center game-over-overlay z-50 p-4">
        <div class="bg-gradient-to-br from-gray-900 to-blue-900 p-6 sm:p-8 rounded-2xl max-w-md w-full border border-blue-500 shadow-2xl">
            <h2 id="game-over-title" class="text-2xl sm:text-3xl font-bold mb-4 text-center text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">éŠæˆ²çµæŸ</h2>
            <div class="space-y-3 sm:space-y-4 mb-6 text-base sm:text-lg">
                <p class="text-lg sm:text-xl text-center">ä½ çš„æˆç¸¾ï¼š</p>
                <div class="flex justify-between items-center border-b border-gray-700 pb-2">
                    <span>å®Œæˆå­—å…ƒï¼š</span>
                    <span id="final-completed" class="font-bold text-cyan-400">0</span>
                </div>
                <div class="flex justify-between items-center border-b border-gray-700 pb-2">
                    <span>æœ€çµ‚å¾—åˆ†ï¼š</span>
                    <span id="final-score" class="font-bold text-yellow-400">0</span>
                </div>
                <div class="flex justify-between items-center border-b border-gray-700 pb-2">
                    <span>éºæ¼æ¬¡æ•¸ï¼š</span>
                    <span id="final-missed" class="font-bold text-red-400">0</span>
                </div>
                <div class="flex justify-between items-center bg-gradient-to-r from-purple-900 to-blue-900 p-3 rounded-lg mt-4">
                    <span class="text-lg font-bold">ğŸ† æ’åï¼š</span>
                    <span id="rank-display" class="text-xl font-bold text-yellow-300">-</span>
                </div>
                <div id="high-score-display" class="text-center text-sm text-gray-400 mt-2">
                    <!-- æ­·å²æœ€é«˜åˆ†é¡¯ç¤º -->
                </div>
            </div>
            
            <!-- TOP 10 æ’è¡Œæ¦œ -->
            <div class="mb-6 bg-gray-900 bg-opacity-50 rounded-lg p-4">
                <h3 class="text-lg font-bold text-center mb-3 text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-400">ğŸ† TOP 10 æ’è¡Œæ¦œ</h3>
                <div id="top10-list" class="space-y-2 text-sm">
                    <!-- TOP 10 åˆ—è¡¨å°‡å‹•æ…‹ç”Ÿæˆ -->
                </div>
            </div>
            <div class="flex justify-center">
                <button id="restart-button" class="px-4 py-2 sm:px-6 sm:py-3 bg-gradient-to-r from-blue-500 to-cyan-500 text-white text-base sm:text-lg font-bold rounded-full hover:from-blue-600 hover:to-cyan-600 transition-all transform hover:scale-105 shadow-lg">å†ç©ä¸€æ¬¡</button>
            </div>
        </div>
    </div>

    <script>
        const bopomofoKeyMap = {
            'ã„…': '1', 'ã„†': 'q', 'ã„‡': 'a', 'ã„ˆ': 'z', 'ã„‰': '2', 'ã„Š': 'w', 'ã„‹': 's', 'ã„Œ': 'x',
            'ã„': 'e', 'ã„': 'd', 'ã„': 'c', 'ã„': 'r', 'ã„‘': 'f', 'ã„’': 'v', 'ã„“': '5', 'ã„”': 't',
            'ã„•': 'g', 'ã„–': 'b', 'ã„—': 'y', 'ã„˜': 'h', 'ã„™': 'n', 'ã„§': 'u', 'ã„¨': 'j', 'ã„©': 'm',
            'ã„š': '8', 'ã„›': 'i', 'ã„œ': 'k', 'ã„': ',', 'ã„': '9', 'ã„Ÿ': 'o', 'ã„ ': 'l', 'ã„¡': '.',
            'ã„¢': '0', 'ã„£': 'p', 'ã„¤': ';', 'ã„¥': '/', 'ã„¦': '-',
            'ËŠ': '6', 'Ë‡': '3', 'Ë‹': '4', 'Ë™': '7'
        };

        const characterData = [
            { char: 'çš„', bopomofo: 'ã„‰ã„œË™' }, { char: 'ä¸€', bopomofo: 'ã„§' }, { char: 'æ˜¯', bopomofo: 'ã„•Ë‹' }, { char: 'ä¸', bopomofo: 'ã„…ã„¨Ë‹' },
            { char: 'äº†', bopomofo: 'ã„Œã„œË™' }, { char: 'æœ‰', bopomofo: 'ã„§ã„¡Ë‡' }, { char: 'å’Œ', bopomofo: 'ã„ã„œËŠ' }, { char: 'äºº', bopomofo: 'ã„–ã„£ËŠ' },
            { char: 'é€™', bopomofo: 'ã„“ã„œË‹' }, { char: 'ä¸­', bopomofo: 'ã„“ã„¨ã„¥' }, { char: 'å¤§', bopomofo: 'ã„‰ã„šË‹' }, { char: 'ç‚º', bopomofo: 'ã„¨ã„ŸËŠ' },
            { char: 'ä¸Š', bopomofo: 'ã„•ã„¤Ë‹' }, { char: 'å€‹', bopomofo: 'ã„ã„œË‹' }, { char: 'åœ‹', bopomofo: 'ã„ã„¨ã„›ËŠ' }, { char: 'æˆ‘', bopomofo: 'ã„¨ã„›Ë‡' },
            { char: 'ä»¥', bopomofo: 'ã„§Ë‡' }, { char: 'è¦', bopomofo: 'ã„§ã„ Ë‹' }, { char: 'ä»–', bopomofo: 'ã„Šã„š' }, { char: 'æ™‚', bopomofo: 'ã„•ËŠ' },
            { char: 'ä¾†', bopomofo: 'ã„Œã„ËŠ' }, { char: 'ç”¨', bopomofo: 'ã„©ã„¥Ë‹' }, { char: 'å€‘', bopomofo: 'ã„‡ã„£Ë™' }, { char: 'ç”Ÿ', bopomofo: 'ã„•ã„¥' },
            { char: 'åˆ°', bopomofo: 'ã„‰ã„ Ë‹' }, { char: 'ä½œ', bopomofo: 'ã„—ã„¨ã„›Ë‹' }, { char: 'åœ°', bopomofo: 'ã„‰ã„§Ë‹' }, { char: 'æ–¼', bopomofo: 'ã„©ËŠ' },
            { char: 'å‡º', bopomofo: 'ã„”ã„¨' }, { char: 'å°±', bopomofo: 'ã„ã„§ã„¡Ë‹' }, { char: 'åˆ†', bopomofo: 'ã„ˆã„£' }, { char: 'å°', bopomofo: 'ã„‰ã„¨ã„ŸË‹' },
            { char: 'æˆ', bopomofo: 'ã„”ã„¥ËŠ' }, { char: 'æœƒ', bopomofo: 'ã„ã„¨ã„ŸË‹' }, { char: 'å¯', bopomofo: 'ã„ã„œË‡' }, { char: 'ä¸»', bopomofo: 'ã„“ã„¨Ë‡' },
            { char: 'ç™¼', bopomofo: 'ã„ˆã„š' }, { char: 'å¹´', bopomofo: 'ã„‹ã„§ã„¢ËŠ' }, { char: 'å‹•', bopomofo: 'ã„‰ã„¨ã„¥Ë‹' }, { char: 'åŒ', bopomofo: 'ã„Šã„¨ã„¥ËŠ' },
            { char: 'å·¥', bopomofo: 'ã„ã„¨ã„¥' }, { char: 'ä¹Ÿ', bopomofo: 'ã„§ã„Ë‡' }, { char: 'èƒ½', bopomofo: 'ã„‹ã„¥ËŠ' }, { char: 'ä¸‹', bopomofo: 'ã„’ã„§ã„šË‹' },
            { char: 'é', bopomofo: 'ã„ã„¨ã„›Ë‹' }, { char: 'å­', bopomofo: 'ã„—Ë‡' }, { char: 'èªª', bopomofo: 'ã„•ã„¨ã„›' }, { char: 'ç”¢', bopomofo: 'ã„”ã„¢Ë‡' },
            { char: 'ç¨®', bopomofo: 'ã„“ã„¨ã„¥Ë‡' }, { char: 'é¢', bopomofo: 'ã„‡ã„§ã„¢Ë‹' }, { char: 'è€Œ', bopomofo: 'ã„¦ËŠ' }, { char: 'æ–¹', bopomofo: 'ã„ˆã„¤' },
            { char: 'å¾Œ', bopomofo: 'ã„ã„¡Ë‹' }, { char: 'å¤š', bopomofo: 'ã„‰ã„¨ã„›' }, { char: 'å®š', bopomofo: 'ã„‰ã„§ã„¥Ë‹' }, { char: 'è¡Œ', bopomofo: 'ã„’ã„§ã„¥ËŠ' },
            { char: 'å­¸', bopomofo: 'ã„’ã„©ã„ËŠ' }, { char: 'æ³•', bopomofo: 'ã„ˆã„šË‡' }, { char: 'æ‰€', bopomofo: 'ã„™ã„¨ã„›Ë‡' }, { char: 'æ°‘', bopomofo: 'ã„‡ã„§ã„£ËŠ' },
            { char: 'å¾—', bopomofo: 'ã„‰ã„œËŠ' }, { char: 'ç¶“', bopomofo: 'ã„ã„§ã„¥' }, { char: 'å', bopomofo: 'ã„•ËŠ' }, { char: 'ä¸‰', bopomofo: 'ã„™ã„¢' },
            { char: 'ä¹‹', bopomofo: 'ã„“' }, { char: 'é€²', bopomofo: 'ã„ã„§ã„£Ë‹' }, { char: 'è‘—', bopomofo: 'ã„“ã„œË™' }, { char: 'ç­‰', bopomofo: 'ã„‰ã„¥Ë‡' },
            { char: 'éƒ¨', bopomofo: 'ã„…ã„¨Ë‹' }, { char: 'åº¦', bopomofo: 'ã„‰ã„¨Ë‹' }, { char: 'å®¶', bopomofo: 'ã„ã„§ã„š' }, { char: 'é›»', bopomofo: 'ã„‰ã„§ã„¢Ë‹' },
            { char: 'åŠ›', bopomofo: 'ã„Œã„§Ë‹' }, { char: 'è£¡', bopomofo: 'ã„Œã„§Ë‡' }, { char: 'å¦‚', bopomofo: 'ã„–ã„¨ËŠ' }, { char: 'æ°´', bopomofo: 'ã„•ã„¨ã„ŸË‡' },
            { char: 'åŒ–', bopomofo: 'ã„ã„¨ã„šË‹' }, { char: 'é«˜', bopomofo: 'ã„ã„ ' }, { char: 'è‡ª', bopomofo: 'ã„—Ë‹' }, { char: 'äºŒ', bopomofo: 'ã„¦Ë‹' },
            { char: 'ç†', bopomofo: 'ã„Œã„§Ë‡' }, { char: 'èµ·', bopomofo: 'ã„‘ã„§Ë‡' }, { char: 'å°', bopomofo: 'ã„’ã„§ã„ Ë‡' }, { char: 'ç‰©', bopomofo: 'ã„¨Ë‹' },
            { char: 'ç¾', bopomofo: 'ã„’ã„§ã„¢Ë‹' }, { char: 'å¯¦', bopomofo: 'ã„•ËŠ' }, { char: 'åŠ ', bopomofo: 'ã„ã„§ã„š' }, { char: 'é‡', bopomofo: 'ã„Œã„§ã„¤Ë‹' },
            { char: 'éƒ½', bopomofo: 'ã„‰ã„¡' }, { char: 'å…©', bopomofo: 'ã„Œã„§ã„¤Ë‡' }, { char: 'é«”', bopomofo: 'ã„Šã„§Ë‡' }, { char: 'åˆ¶', bopomofo: 'ã„“Ë‹' },
            { char: 'æ©Ÿ', bopomofo: 'ã„ã„§' }, { char: 'ç•¶', bopomofo: 'ã„‰ã„¤' }, { char: 'ä½¿', bopomofo: 'ã„•Ë‡' }, { char: 'é»', bopomofo: 'ã„‰ã„§ã„¢Ë‡' },
            { char: 'å¾', bopomofo: 'ã„˜ã„¨ã„¥ËŠ' }, { char: 'æ¥­', bopomofo: 'ã„§ã„Ë‹' }, { char: 'æœ¬', bopomofo: 'ã„…ã„£Ë‡' }, { char: 'å»', bopomofo: 'ã„‘ã„©Ë‹' },
            { char: 'æŠŠ', bopomofo: 'ã„…ã„šË‡' }, { char: 'é•·', bopomofo: 'ã„“ã„¤Ë‡' }, { char: 'è¦‹', bopomofo: 'ã„ã„§ã„¢Ë‹' }, { char: 'å·±', bopomofo: 'ã„ã„§Ë‡' },
            { char: 'é‡', bopomofo: 'ã„“ã„¨ã„¥Ë‹' }, { char: 'æ­¤', bopomofo: 'ã„˜Ë‡' }, { char: 'é–“', bopomofo: 'ã„ã„§ã„¢' }, { char: 'å‘', bopomofo: 'ã„’ã„§ã„¤Ë‹' },
            { char: 'é“', bopomofo: 'ã„‰ã„ Ë‹' }, { char: 'å‘½', bopomofo: 'ã„‡ã„§ã„¥Ë‹' }, { char: 'æƒ³', bopomofo: 'ã„’ã„§ã„¤Ë‡' }, { char: 'æƒ…', bopomofo: 'ã„‘ã„§ã„¥ËŠ' },
            { char: 'äº‹', bopomofo: 'ã„•Ë‹' }, { char: 'çŸ¥', bopomofo: 'ã„“' }, { char: 'è€…', bopomofo: 'ã„“ã„œË‡' }, { char: 'çµ¦', bopomofo: 'ã„ã„ŸË‡' },
            { char: 'æ¬¡', bopomofo: 'ã„˜Ë‹' }, { char: 'ä½ ', bopomofo: 'ã„‹ã„§Ë‡' }, { char: 'å¥½', bopomofo: 'ã„ã„ Ë‡' }, { char: 'æœ‹', bopomofo: 'ã„†ã„¥ËŠ' },
            { char: 'å‹', bopomofo: 'ã„§ã„¡Ë‡' }, { char: 'å¥¹', bopomofo: 'ã„Šã„š' }, { char: 'å¿«', bopomofo: 'ã„ã„¨ã„Ë‹' }, { char: 'æ¨‚', bopomofo: 'ã„Œã„œË‹' },
            { char: 'æ„›', bopomofo: 'ã„Ë‹' }, { char: 'å…‰', bopomofo: 'ã„ã„¨ã„¤' }, { char: 'é¢¨', bopomofo: 'ã„ˆã„¥' }, { char: 'èŠ±', bopomofo: 'ã„ã„¨ã„š' },
            { char: 'å±±', bopomofo: 'ã„•ã„¢' }, { char: 'å¤©', bopomofo: 'ã„Šã„§ã„¢' }, { char: 'é³¥', bopomofo: 'ã„‹ã„§ã„ Ë‡' },
            { char: 'é­š', bopomofo: 'ã„©ËŠ' }, { char: 'æ›¸', bopomofo: 'ã„•ã„¨' }, { char: 'çœ‹', bopomofo: 'ã„ã„¢Ë‹' }, { char: 'è½', bopomofo: 'ã„Šã„§ã„¥' }
        ];

        function convertBopomofoToEnglish(bopomofo) {
            const tones = ['ËŠ', 'Ë‡', 'Ë‹', 'Ë™'];
            let keyString = '';
            let hasTone = false;
            for (const char of bopomofo) {
                if (bopomofoKeyMap[char]) {
                    keyString += bopomofoKeyMap[char];
                    if (tones.includes(char)) {
                        hasTone = true;
                    }
                }
            }
            if (!hasTone) {
                keyString += ' '; // ä¸€è²ä»¥ç©ºç™½éµçµå°¾
            }
            return keyString;
        }

        const characterDataWithKeys = characterData.map(data => ({
            ...data,
            englishKeys: convertBopomofoToEnglish(data.bopomofo)
        }));

        let gameActive = false;
        let fallingCharacters = [];
        let completedCount = 0;
        let score = 0;
        let missedCount = 0; 
        let maxMisses = 5;
        let initialCharactersOnScreen = 1;
        let isComposing = false; // ç”¨æ–¼è¿½è¹¤æ³¨éŸ³è¼¸å…¥æ³•çµ„å­—ç‹€æ…‹
        
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameContainer = document.getElementById('game-container');
        const charactersContainer = document.getElementById('characters-container');
        const inputField = document.getElementById('input-field');
        const completedCountElement = document.getElementById('completed-count');
        const scoreElement = document.getElementById('score');
        const missedCountElement = document.getElementById('missed-count');
        const gameOverScreen = document.getElementById('game-over');
        const gameOverTitle = document.getElementById('game-over-title');
        const finalCompletedElement = document.getElementById('final-completed');
        const finalScoreElement = document.getElementById('final-score');
        const finalMissedElement = document.getElementById('final-missed');
        const rankDisplayElement = document.getElementById('rank-display');
        const highScoreDisplayElement = document.getElementById('high-score-display');
        const top10ListElement = document.getElementById('top10-list');
        const restartButton = document.getElementById('restart-button');
        
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        
        function getRandomUniqueCharacter() {
            const onScreenChars = fallingCharacters.map(fc => fc.char);
            let availableCharsData = characterDataWithKeys.filter(data => !onScreenChars.includes(data.char));
            if (availableCharsData.length === 0) {
                availableCharsData = [...characterDataWithKeys];
            }
            const randomIndex = Math.floor(Math.random() * availableCharsData.length);
            return availableCharsData[randomIndex];
        }

        function getCurrentMaxCharacters() {
            // æ¯å®Œæˆ20å€‹å­—ï¼ŒåŒæ™‚æ‰è½çš„å­—æ•¸å¢åŠ 1
            return Math.floor(completedCount / 20) + 1;
        }

        // æˆç¸¾ç®¡ç†å‡½æ•¸
        function saveScore(completed, score, missed) {
            const scoreData = {
                completed: completed,
                score: score,
                missed: missed,
                date: new Date().toISOString(),
                timestamp: Date.now()
            };
            
            // å¾ localStorage è®€å–æ­·å²æˆç¸¾
            let scores = getScores();
            scores.push(scoreData);
            
            // æŒ‰åˆ†æ•¸æ’åºï¼ˆé™åºï¼‰ï¼Œåªä¿ç•™å‰ 10 å
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 10);
            
            localStorage.setItem('typingGameScores', JSON.stringify(scores));
            return scoreData;
        }
        
        function getScores() {
            const stored = localStorage.getItem('typingGameScores');
            return stored ? JSON.parse(stored) : [];
        }
        
        function calculateRank(currentScore) {
            const scores = getScores();
            if (scores.length === 0) {
                // ç¬¬ä¸€æ¬¡éŠæˆ²
                return { rank: 1, isNewRecord: false, inTop10: true, highScore: null };
            }
            
            // æŒ‰åˆ†æ•¸æ’åºï¼ˆé™åºï¼‰
            const sortedScores = [...scores].sort((a, b) => b.score - a.score);
            const highScore = sortedScores[0].score;
            
            // è¨ˆç®—æ’å
            let rank = 1;
            for (let i = 0; i < sortedScores.length; i++) {
                if (currentScore > sortedScores[i].score) {
                    rank = i + 1;
                    break;
                } else if (i === sortedScores.length - 1) {
                    // æ¯”æ‰€æœ‰è¨˜éŒ„éƒ½ä½æˆ–ç›¸ç­‰
                    rank = sortedScores.length + 1;
                }
            }
            
            const inTop10 = rank <= 10;
            const isNewRecord = currentScore > highScore;
            
            return { rank: rank, isNewRecord: isNewRecord, inTop10: inTop10, highScore: highScore };
        }
        
        function displayRankInfo(rank, isNewRecord, inTop10, highScore, currentScore) {
            // é¡¯ç¤ºæ’å
            if (inTop10) {
                const rankText = `ç¬¬ ${rank} å`;
                rankDisplayElement.textContent = rankText;
            } else {
                rankDisplayElement.textContent = 'æœªä¸Šæ¦œ';
            }
            
            // é¡¯ç¤ºé¡å¤–ä¿¡æ¯
            if (rank === 1 && !highScore) {
                // ç¬¬ä¸€æ¬¡éŠæˆ²
                highScoreDisplayElement.innerHTML = '<span class="text-cyan-400">é€™æ˜¯ä½ çš„ç¬¬ä¸€æ¬¡éŠæˆ²ï¼</span>';
            } else if (isNewRecord) {
                highScoreDisplayElement.innerHTML = '<span class="text-yellow-400 font-bold">ğŸ‰ æ­å–œï¼å‰µé€ æ–°ç´€éŒ„ï¼</span>';
            } else if (inTop10) {
                const difference = highScore - currentScore;
                highScoreDisplayElement.innerHTML = `<span class="text-gray-400">æœ€é«˜åˆ†ï¼š${highScore} åˆ†</span><br><span class="text-sm text-gray-500">è·é›¢æœ€é«˜åˆ†é‚„å·® ${difference} åˆ†</span>`;
            } else {
                // æœªä¸Šæ¦œï¼Œé¡¯ç¤ºè·é›¢ TOP 10 çš„å·®è·
                const scores = getScores();
                const lowestTop10Score = scores[Math.min(9, scores.length - 1)]?.score || 0;
                const difference = lowestTop10Score - currentScore + 1;
                highScoreDisplayElement.innerHTML = `<span class="text-gray-400">ç¹¼çºŒåŠªåŠ›ï¼</span><br><span class="text-sm text-gray-500">è·é›¢ TOP 10 é‚„å·® ${difference} åˆ†</span>`;
            }
        }
        
        function getTop10Scores() {
            const scores = getScores();
            // æŒ‰åˆ†æ•¸æ’åºï¼ˆé™åºï¼‰ï¼Œå–å‰ 10 å
            return [...scores].sort((a, b) => b.score - a.score).slice(0, 10);
        }
        
        function formatDate(isoString) {
            const date = new Date(isoString);
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${month}/${day} ${hours}:${minutes}`;
        }
        
        function displayTop10(currentScore) {
            const top10 = getTop10Scores();
            
            if (top10.length === 0) {
                top10ListElement.innerHTML = '<p class="text-center text-gray-400">é‚„æ²’æœ‰æ­·å²è¨˜éŒ„</p>';
                return;
            }
            
            let html = '';
            top10.forEach((scoreData, index) => {
                const rank = index + 1;
                const isCurrentScore = Math.abs(scoreData.timestamp - Date.now()) < 1000; // 1ç§’å…§çš„è¨˜éŒ„è¦–ç‚ºç•¶å‰æˆç¸¾
                const bgClass = isCurrentScore ? 'bg-gradient-to-r from-yellow-900 to-orange-900 border border-yellow-500' : 'bg-gray-800 bg-opacity-50';
                const medalEmoji = rank === 1 ? 'ğŸ¥‡' : rank === 2 ? 'ğŸ¥ˆ' : rank === 3 ? 'ğŸ¥‰' : `${rank}.`;
                
                html += `
                    <div class="${bgClass} p-2 rounded flex justify-between items-center">
                        <div class="flex items-center gap-2 flex-1">
                            <span class="font-bold ${rank <= 3 ? 'text-lg' : ''}">${medalEmoji}</span>
                            <div class="flex-1">
                                <div class="flex justify-between">
                                    <span class="font-bold text-yellow-400">${scoreData.score} åˆ†</span>
                                    <span class="text-xs text-gray-400">${formatDate(scoreData.date)}</span>
                                </div>
                                <div class="text-xs text-gray-300">
                                    å®Œæˆ ${scoreData.completed} å­— | éºæ¼ ${scoreData.missed} æ¬¡
                                </div>
                            </div>
                        </div>
                        ${isCurrentScore ? '<span class="text-yellow-400 text-xs ml-2">â† æœ¬æ¬¡</span>' : ''}
                    </div>
                `;
            });
            
            top10ListElement.innerHTML = html;
        }

        function spawnNewCharacter() {
            if (!gameActive) return;

            // æª¢æŸ¥ç•¶å‰ç•«é¢ä¸Šçš„å­—æ•¸æ˜¯å¦å·²é”åˆ°æœ€å¤§å€¼
            const maxChars = getCurrentMaxCharacters();
            if (fallingCharacters.length >= maxChars) return;

            const charData = getRandomUniqueCharacter();
            if (!charData) return; 

            const charElement = document.createElement('div');
            charElement.className = 'falling-character';
            charElement.innerHTML = `<span class="text-2xl">${charData.char}</span><span class="text-xs text-cyan-300 mt-1">${charData.bopomofo} (${charData.englishKeys})</span>`;
            
            charElement.dataset.char = charData.char;
            charElement.dataset.bopomofo = charData.bopomofo;
            charElement.dataset.englishKeys = charData.englishKeys;

            const containerWidth = charactersContainer.clientWidth;
            let effectiveCharWidth = 80;
            if (window.innerWidth <= 768) effectiveCharWidth = 70;
            if (window.innerWidth <= 640) effectiveCharWidth = 65;

            const left = Math.random() * (containerWidth - effectiveCharWidth);
            charElement.style.left = `${Math.max(0, left)}px`;

            const duration = 15 + Math.random() * 10;
            charElement.style.animationName = 'fall';
            charElement.style.animationDuration = `${duration}s`;

            charactersContainer.appendChild(charElement);

            const newFcData = {
                element: charElement,
                char: charData.char,
                bopomofo: charData.bopomofo,
                englishKeys: charData.englishKeys,
                duration: duration,
                startTime: Date.now()
            };
            fallingCharacters.push(newFcData);

            charElement.addEventListener('animationend', function handleAnimationEnd() {
                this.removeEventListener('animationend', handleAnimationEnd);
                const index = fallingCharacters.findIndex(fc => fc.element === this);
                if (index > -1) {
                    fallingCharacters.splice(index, 1);
                }
                if (this.parentNode) {
                    this.parentNode.removeChild(this);
                }
                
                // å­—æ‰è½åˆ°åº•éƒ¨ï¼Œå¢åŠ éºæ¼è¨ˆæ•¸
                if (gameActive) {
                    missedCount++;
                    missedCountElement.textContent = missedCount;
                    
                    // æª¢æŸ¥æ˜¯å¦é”åˆ°éºæ¼ä¸Šé™
                    if (missedCount >= maxMisses) {
                        endGame("GAME OVER");
                        return;
                    }
                    
                    // æª¢æŸ¥ç•¶å‰æ‡‰è©²æœ‰å¤šå°‘å€‹å­—ï¼Œå¯èƒ½éœ€è¦ç”Ÿæˆå¤šå€‹
                    const maxChars = getCurrentMaxCharacters();
                    while (fallingCharacters.length < maxChars && gameActive) {
                        spawnNewCharacter();
                    }
                }
            });
        }

        function startGame() {
            startScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            gameOverScreen.classList.add('hidden');
            
            gameActive = true;
            completedCount = 0;
            score = 0;
            missedCount = 0;
            fallingCharacters = [];
            charactersContainer.innerHTML = ''; 
            
            completedCountElement.textContent = completedCount;
            scoreElement.textContent = score;
            missedCountElement.textContent = missedCount;
            
            inputField.focus();
            inputField.value = '';
            updateTargetLocking(''); // ç¢ºä¿æ²’æœ‰é–å®šç‹€æ…‹
            setupInputListeners();

            // æ ¹æ“šç•¶å‰ç›®æ¨™æ•¸é‡ç”Ÿæˆåˆå§‹å­—å…ƒ
            const maxChars = getCurrentMaxCharacters();
            for (let i = 0; i < maxChars; i++) {
                spawnNewCharacter();
            }
        }
        
        let inputListenersSetup = false;
        
        function setupInputListeners() {
            if (inputListenersSetup) return;

            const inputHandler = (e) => {
                // å°æ–¼éçµ„å­—è¼¸å…¥(å¦‚è‹±æ–‡éµç›¤)ï¼Œå³æ™‚è™•ç†
                if (!isComposing) {
                    const inputValue = e.target.value;
                    
                    // æª¢æ¸¬ quit å‘½ä»¤
                    if (inputValue.toLowerCase() === 'quit') {
                        const confirmed = confirm('ç¢ºå®šè¦çµæŸéŠæˆ²å—ï¼Ÿç›®å‰çš„æˆç¸¾æœƒè¢«è¨˜éŒ„ã€‚');
                        if (confirmed) {
                            endGame('æå‰çµæŸ');
                        }
                        inputField.value = '';
                        updateTargetLocking('');
                        return;
                    }
                    
                    // æ›´æ–°ç›®æ¨™é–å®šé«˜äº®
                    updateTargetLocking(inputValue);
                    
                    processInput(inputValue);
                    
                    // æª¢æŸ¥è¼¸å…¥æ˜¯å¦åŒ…å«è²èª¿éµ (3, 4, 6, 7)
                    // å¦‚æœåŒ…å«è²èª¿ï¼Œè™•ç†å¾Œç«‹å³æ¸…ç©ºè¼¸å…¥å€
                    const toneKeys = ['3', '4', '6', '7'];
                    const lastChar = inputValue.slice(-1);
                    if (toneKeys.includes(lastChar)) {
                        setTimeout(() => {
                            if (!isComposing) {
                                inputField.value = '';
                                updateTargetLocking(''); // æ¸…é™¤æ‰€æœ‰é–å®š
                            }
                        }, 10);
                    }
                }
            };

            const compositionStartHandler = () => {
                isComposing = true;
            };

            const compositionUpdateHandler = (e) => {
                // åœ¨çµ„å­—éç¨‹ä¸­ä¹Ÿæ›´æ–°é–å®šç‹€æ…‹
                if (e.data) {
                    updateTargetLocking(e.data);
                }
            };

            const compositionEndHandler = (e) => {
                isComposing = false;
                // åœ¨çµ„å­—çµæŸå¾Œï¼Œè™•ç†æœ€çµ‚çš„æ³¨éŸ³å­—ä¸²
                processInput(e.data || e.target.value);
                // ä½¿ç”¨ setTimeout ç¢ºä¿ç€è¦½å™¨å®Œæˆæ¸²æŸ“å¾Œå†æ¸…ç©ºï¼Œé¿å…è¡çª
                setTimeout(() => {
                    if (inputField.value === (e.data || e.target.value)) {
                       inputField.value = '';
                       updateTargetLocking(''); // æ¸…é™¤æ‰€æœ‰é–å®š
                    }
                }, 0);
            };
            
            const keyDownHandler = (e) => {
                // ç©ºç™½éµä»£è¡¨ä¸€è²ï¼ˆç„¡è²èª¿ç¬¦è™Ÿï¼‰
                if (e.key === ' ') {
                    const currentInput = e.target.value;
                    if (!currentInput) return;

                    const potentialMatch = currentInput + ' ';
                    const targetFc = findMatchingChar(potentialMatch);

                    e.preventDefault();
                    if (targetFc) {
                        handleSuccess(targetFc);
                    }
                    // ä¸è«–æ˜¯å¦æˆåŠŸï¼Œéƒ½æ¸…é™¤è¼¸å…¥å€å’Œé–å®šç‹€æ…‹
                    inputField.value = '';
                    updateTargetLocking('');
                }
            };

            // ç¢ºä¿ç§»é™¤èˆŠçš„ç›£è½å™¨ï¼Œé¿å…é‡è¤‡ç¶å®š
            inputField.removeEventListener('input', inputHandler);
            inputField.removeEventListener('keydown', keyDownHandler);
            inputField.removeEventListener('compositionstart', compositionStartHandler);
            inputField.removeEventListener('compositionupdate', compositionUpdateHandler);
            inputField.removeEventListener('compositionend', compositionEndHandler);

            // é‡æ–°ç¶å®šç›£è½å™¨
            inputField.addEventListener('input', inputHandler);
            inputField.addEventListener('keydown', keyDownHandler);
            inputField.addEventListener('compositionstart', compositionStartHandler);
            inputField.addEventListener('compositionupdate', compositionUpdateHandler);
            inputField.addEventListener('compositionend', compositionEndHandler);

            inputListenersSetup = true;
        }

        function findMatchingChar(typedValue) {
            let targetFc = null;
            let maxProgress = -1;

            for (const fc of fallingCharacters) {
                if ((fc.bopomofo === typedValue || fc.char === typedValue || fc.englishKeys.toLowerCase() === typedValue.toLowerCase()) && fc.element.parentNode) {
                    const elapsedTime = (Date.now() - fc.startTime) / 1000;
                    const progress = elapsedTime / fc.duration;
                    
                    if (progress > maxProgress) {
                        maxProgress = progress;
                        targetFc = fc;
                    }
                }
            }
            return targetFc;
        }

        function handleSuccess(fc) {
            const fcIndex = fallingCharacters.findIndex(item => item === fc);
            if (fcIndex === -1) return;

            fc.element.classList.add('hit');
            fc.element.classList.remove('locked'); // ç§»é™¤é–å®šç‹€æ…‹
            
            const elapsedTime = (Date.now() - fc.startTime) / 1000;
            const speedBonus = Math.max(1, Math.floor(10 - elapsedTime * 0.5));
            const pointsEarned = 50 + speedBonus * 5;
            
            score += pointsEarned;
            scoreElement.textContent = score;
            
            const pointsIndicator = document.createElement('div');
            pointsIndicator.textContent = `+${pointsEarned}`;
            pointsIndicator.className = 'absolute text-yellow-300 font-bold text-lg sm:text-xl';
            const rect = fc.element.getBoundingClientRect();
            pointsIndicator.style.left = `${rect.left + window.scrollX}px`;
            pointsIndicator.style.top = `${rect.top + window.scrollY}px`;
            pointsIndicator.style.animation = 'fadeUpAndOut 1s forwards ease-out';
            document.body.appendChild(pointsIndicator);
            setTimeout(() => pointsIndicator.parentNode?.removeChild(pointsIndicator), 950);
            
            setTimeout(() => fc.element.parentNode?.removeChild(fc.element), 200);
            fallingCharacters.splice(fcIndex, 1);
            
            completedCount++;
            completedCountElement.textContent = completedCount;
            
            if (gameActive) {
                // æª¢æŸ¥ç•¶å‰æ‡‰è©²æœ‰å¤šå°‘å€‹å­—ï¼Œå¯èƒ½éœ€è¦ç”Ÿæˆå¤šå€‹
                const maxChars = getCurrentMaxCharacters();
                while (fallingCharacters.length < maxChars && gameActive) {
                    spawnNewCharacter();
                }
            }
        }
        
        function processInput(inputValue) {
            if (!inputValue || !gameActive) return;
            
            const targetFc = findMatchingChar(inputValue);

            if (targetFc) {
                handleSuccess(targetFc);
                // è‹±æ–‡è¼¸å…¥æ¨¡å¼ä¸‹ï¼ŒæˆåŠŸå¾Œç«‹å³æ¸…ç©º
                if (!isComposing) {
                    inputField.value = '';
                }
            }
        }
        
        function updateTargetLocking(inputValue) {
            // æ›´æ–°æ‰€æœ‰å­—å…ƒçš„é–å®šç‹€æ…‹
            fallingCharacters.forEach(fc => {
                if (!fc.element.parentNode) return;
                
                const isMatch = inputValue && (
                    fc.englishKeys.toLowerCase().startsWith(inputValue.toLowerCase()) ||
                    fc.bopomofo.startsWith(inputValue)
                );
                
                if (isMatch) {
                    fc.element.classList.add('locked');
                } else {
                    fc.element.classList.remove('locked');
                }
            });
            
            // å¦‚æœè¼¸å…¥ç‚ºç©ºï¼Œç§»é™¤æ‰€æœ‰é–å®š
            if (!inputValue) {
                fallingCharacters.forEach(fc => {
                    if (fc.element.parentNode) {
                        fc.element.classList.remove('locked');
                    }
                });
            }
        }
        
        function endGame(reason = "éŠæˆ²çµæŸ") {
            if (!gameActive) return;
            gameActive = false;
            
            gameOverScreen.classList.remove('hidden');
            gameOverTitle.textContent = reason;
            
            finalCompletedElement.textContent = completedCount; 
            finalScoreElement.textContent = score;
            finalMissedElement.textContent = missedCount;
            
            // å…ˆè¨ˆç®—æ’åï¼Œå†ä¿å­˜æˆç¸¾
            const rankInfo = calculateRank(score);
            saveScore(completedCount, score, missedCount);
            displayRankInfo(rankInfo.rank, rankInfo.isNewRecord, rankInfo.inTop10, rankInfo.highScore, score);
            
            // é¡¯ç¤º TOP 10 æ’è¡Œæ¦œ
            displayTop10(score);
            
            charactersContainer.innerHTML = '';
            fallingCharacters = [];
        }
        
        const styleSheet = document.createElement('style');
        styleSheet.textContent = `
            @keyframes fadeUpAndOut {
                0% { opacity: 1; transform: translateY(0) scale(0.8); }
                70% { opacity: 0.8; transform: translateY(-40px) scale(1.1); }
                100% { opacity: 0; transform: translateY(-60px) scale(0.5); }
            }
        `;
        document.head.appendChild(styleSheet);
        
        window.addEventListener('resize', () => {
            if (gameActive) {
                const containerWidth = charactersContainer.clientWidth;
                fallingCharacters.forEach(({ element }) => {
                    if (element.parentNode) {
                        let effectiveCharWidth = 80;
                        if (window.innerWidth <= 768) effectiveCharWidth = 70;
                        if (window.innerWidth <= 640) effectiveCharWidth = 65;
                        
                        const currentLeftPx = parseFloat(element.style.left);
                        const lastContainerWidth = parseFloat(element.dataset.lastContainerWidth || containerWidth);
                        
                        let newLeft;
                        if (element.dataset.lastContainerWidth && lastContainerWidth > 0) {
                            const currentLeftRatio = currentLeftPx / lastContainerWidth;
                            newLeft = currentLeftRatio * containerWidth;
                        } else {
                           newLeft = Math.random() * (containerWidth - effectiveCharWidth);
                        }
                        newLeft = Math.max(0, Math.min(newLeft, containerWidth - effectiveCharWidth));
                        element.style.left = `${newLeft}px`;
                        element.dataset.lastContainerWidth = containerWidth;
                    }
                });
            }
        });
    </script>

</body></html>
